<!DOCTYPE html>
<!-- saved from url=(0046)https://golang-china.appspot.com/pkg/net/http/ -->
<html data-find="_4"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


<!--
  <title>http - The Go Programming Language</title>
-->
  <title>http - Go 编程语言</title>

<link type="text/css" rel="stylesheet" href="./http - Go 编程语言_files/style.css">

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="https://golang-china.appspot.com/opensearch.xml">

<link rel="stylesheet" href="https://golang-china.appspot.com/lib/godoc/jquery.treeview.css">
<script type="text/javascript">window.initFuncs = [];</script>
</head>
<body data-find="_3">

<div id="lowframe" style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">

<form method="GET" action="https://golang-china.appspot.com/search" id="1051804472">
<div id="menu" style="min-width: 650px;">
<!--
<a href="/doc/">Documents</a>
<a href="/pkg/">Packages</a>
<a href="/project/">The Project</a>
<a href="/help/">Help</a>
<a href="/blog/">Blog</a>
-->
<a href="https://golang-china.appspot.com/doc/">文档</a>
<a href="https://golang-china.appspot.com/pkg/">包</a>
<a href="https://golang-china.appspot.com/project/">项目</a>
<a href="https://golang-china.appspot.com/help/">帮助</a>
<a href="https://golang-china.appspot.com/blog/">博客</a>

<!--
<a id="playgroundButton" href="http://play.golang.org/" title="Show Go Playground">Play</a>
-->
<a id="playgroundButton" href="http://play.golang.org/" title="显示 Go 操场" style="display: inline;">运行</a>

<!--
<input type="text" id="search" name="q" class="inactive" value="Search" placeholder="Search">
-->
<input type="text" id="search" name="q" class="inactive" value="搜索" placeholder="搜索">
</div>
<!--
<div id="heading"><a href="/">The Go Programming Language</a></div>
-->
<div id="heading"><a href="https://golang-china.appspot.com/">Go 编程语言</a></div>
</form>

</div></div>


<div id="playground" class="play">
	<div class="input"><textarea class="code">package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}</textarea></div>
	<div class="output"></div>
	<div class="buttons">
<!--
		<a class="run" title="Run this code [shift-enter]">Run</a>
		<a class="fmt" title="Format this code">Format</a>
		<a class="share" title="Share this code">Share</a>
-->
		<a class="run" title="运行此代码[Shift-Enter]">运行</a>
		<a class="fmt" title="格式化此代码">格式化</a>
		<a class="share" title="分享此代码">分享</a>
	</div>
</div>


<div id="page" class="wide" tabindex="-1" data-find="_2" style="outline: 0px;">
<div class="container" data-find="_1">


<div class="lang-switch-button-group" role="group">
  <button type="button" class="btn btn-default" onclick="$(&quot;div.english&quot;).css(&quot;display&quot;, &quot;block&quot;);$(&quot;div.chinese&quot;).css(&quot;display&quot;, &quot;none&quot;);console.log(&quot;lang-en&quot;);">英文</button>
  <button type="button" class="btn btn-default" onclick="$(&quot;div.english&quot;).css(&quot;display&quot;,&quot;block&quot;);$(&quot;div.chinese&quot;).css(&quot;display&quot;,&quot;block&quot;);console.log(&quot;lang-en-zh&quot;);">对照</button>
  <button type="button" class="btn btn-default" onclick="$(&quot;div.english&quot;).css(&quot;display&quot;,&quot;none&quot;);$(&quot;div.chinese&quot;).css(&quot;display&quot;,&quot;block&quot;);console.log(&quot;lang-zh&quot;);">中文</button>
</div>



  <h1>Package http</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type="text/javascript">
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "net/http"</code></dd>
			</dl>
			<dl>
<!--
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
-->
			<dd><a href="https://golang-china.appspot.com/pkg/net/http/#pkg-overview" class="overviewLink">概览</a></dd>
			<dd><a href="https://golang-china.appspot.com/pkg/net/http/#pkg-index" class="indexLink">索引</a></dd>
			
<!--
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
-->
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#pkg-examples" class="examplesLink">示例</a></dd>
			
			
<!--
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
-->
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#pkg-subdirectories">子目录</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible" data-find="_6">
			<div class="collapsed">
<!--
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
-->
				<h2 class="toggleButton" title="点此显示概览">概览 ▹</h2>
			</div>
			<div class="expanded" data-find="_5">
<!--
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
-->
				<h2 class="toggleButton" title="点此隐藏概览">概览 ▾</h2>
				<p>
http包提供了HTTP客户端和服务端的实现。
</p>
<p>
Get、Head、Post和PostForm函数发出HTTP/ HTTPS请求。
</p>
<pre>resp, err := http.Get("<a href="http://example.com/">http://example.com/</a>")
...
resp, err := http.Post("<a href="http://example.com/upload">http://example.com/upload</a>", "image/jpeg", &amp;buf)
...
resp, err := http.PostForm("<a href="http://example.com/form">http://example.com/form</a>",
	url.Values{"key": {"Value"}, "id": {"123"}})
</pre>
<p>
程序在使用完回复后必须关闭回复的主体。
</p>
<pre>resp, err := http.Get("<a href="http://example.com/">http://example.com/</a>")
if err != nil {
	// handle error
}
defer resp.Body.Close()
body, err := ioutil.ReadAll(resp.Body)
// ...
</pre>
<p>
要管理HTTP客户端的头域、重定向策略和其他设置，创建一个Client：
</p>
<pre>client := &amp;http.Client{
	CheckRedirect: redirectPolicyFunc,
}
resp, err := client.Get("<a href="http://example.com/">http://example.com</a>")
// ...
req, err := http.NewRequest("GET", "<a href="http://example.com/">http://example.com</a>", nil)
// ...
req.Header.Add("If-None-Match", `W/"wyzzy"`)
resp, err := client.Do(req)
// ...
</pre>
<p>
要管理代理、TLS配置、keep-alive、压缩和其他设置，创建一个Transport：
</p>
<pre>tr := &amp;http.Transport{
	TLSClientConfig:    &amp;tls.Config{RootCAs: pool},
	DisableCompression: true,
}
client := &amp;http.Client{Transport: tr}
resp, err := client.Get("<a href="https://example.com/">https://example.com</a>")
</pre>
<p>
Client和Transport类型都可以安全的被多个go程同时使用。出于效率考虑，应该一次建立、尽量重用。
</p>
<p>
ListenAndServe使用指定的监听地址和处理器启动一个HTTP服务端。处理器参数通常是nil，这表示采用包变量DefaultServeMux作为处理器。Handle和HandleFunc函数可以向DefaultServeMux添加处理器。
</p>
<pre>http.Handle("/foo", fooHandler)
http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))
})
log.Fatal(http.ListenAndServe(":8080", nil))
</pre>
<p>
要管理服务端的行为，可以创建一个自定义的Server：
</p>
<pre>s := &amp;http.Server{
	Addr:           ":8080",
	Handler:        myHandler,
	ReadTimeout:    10 * time.Second,
	WriteTimeout:   10 * time.Second,
	MaxHeaderBytes: 1 &lt;&lt; 20,
}
log.Fatal(s.ListenAndServe())
</pre>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
<!--
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
-->
			<h2 class="toggleButton" title="点此显示素引">索引 ▹</h2>
		</div>
		<div class="expanded">
<!--
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>
-->
			<h2 class="toggleButton" title="点此隐藏索引">索引 ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
<!--
				<dd><a href="#pkg-constants">Constants</a></dd>
-->
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#pkg-constants">常量</a></dd>
			
			
<!--
				<dd><a href="#pkg-variables">Variables</a></dd>
-->
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#pkg-variables">变量</a></dd>
			
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#CanonicalHeaderKey">func CanonicalHeaderKey(s string) string</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#DetectContentType">func DetectContentType(data []byte) string</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#Error">func Error(w ResponseWriter, error string, code int)</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#Handle">func Handle(pattern string, handler Handler)</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#HandleFunc">func HandleFunc(pattern string, handler func(ResponseWriter, *Request))</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#ListenAndServe">func ListenAndServe(addr string, handler Handler) error</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#ListenAndServeTLS">func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) error</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#MaxBytesReader">func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#NotFound">func NotFound(w ResponseWriter, r *Request)</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#ParseHTTPVersion">func ParseHTTPVersion(vers string) (major, minor int, ok bool)</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#ParseTime">func ParseTime(text string) (t time.Time, err error)</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#ProxyFromEnvironment">func ProxyFromEnvironment(req *Request) (*url.URL, error)</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#ProxyURL">func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#Redirect">func Redirect(w ResponseWriter, r *Request, urlStr string, code int)</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#Serve">func Serve(l net.Listener, handler Handler) error</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#ServeContent">func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#ServeFile">func ServeFile(w ResponseWriter, r *Request, name string)</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#SetCookie">func SetCookie(w ResponseWriter, cookie *Cookie)</a></dd>
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#StatusText">func StatusText(code int) string</a></dd>
			
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#Client">type Client</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Client.Do">func (c *Client) Do(req *Request) (resp *Response, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Client.Get">func (c *Client) Get(url string) (resp *Response, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Client.Head">func (c *Client) Head(url string) (resp *Response, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Client.Post">func (c *Client) Post(url string, bodyType string, body io.Reader) (resp *Response, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Client.PostForm">func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)</a></dd>
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#CloseNotifier">type CloseNotifier</a></dd>
				
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#ConnState">type ConnState</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#ConnState.String">func (c ConnState) String() string</a></dd>
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#Cookie">type Cookie</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Cookie.String">func (c *Cookie) String() string</a></dd>
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#CookieJar">type CookieJar</a></dd>
				
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#Dir">type Dir</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Dir.Open">func (d Dir) Open(name string) (File, error)</a></dd>
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#File">type File</a></dd>
				
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#FileSystem">type FileSystem</a></dd>
				
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#Flusher">type Flusher</a></dd>
				
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#Handler">type Handler</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#FileServer">func FileServer(root FileSystem) Handler</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#NotFoundHandler">func NotFoundHandler() Handler</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#RedirectHandler">func RedirectHandler(url string, code int) Handler</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#StripPrefix">func StripPrefix(prefix string, h Handler) Handler</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#TimeoutHandler">func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler</a></dd>
				
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#HandlerFunc">type HandlerFunc</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#HandlerFunc.ServeHTTP">func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)</a></dd>
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#Header">type Header</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Header.Add">func (h Header) Add(key, value string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Header.Del">func (h Header) Del(key string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Header.Get">func (h Header) Get(key string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Header.Set">func (h Header) Set(key, value string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Header.Write">func (h Header) Write(w io.Writer) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Header.WriteSubset">func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error</a></dd>
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#Hijacker">type Hijacker</a></dd>
				
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#ProtocolError">type ProtocolError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#ProtocolError.Error">func (err *ProtocolError) Error() string</a></dd>
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#Request">type Request</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#NewRequest">func NewRequest(method, urlStr string, body io.Reader) (*Request, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#ReadRequest">func ReadRequest(b *bufio.Reader) (req *Request, err error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.AddCookie">func (r *Request) AddCookie(c *Cookie)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.BasicAuth">func (r *Request) BasicAuth() (username, password string, ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.Cookie">func (r *Request) Cookie(name string) (*Cookie, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.Cookies">func (r *Request) Cookies() []*Cookie</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.FormFile">func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.FormValue">func (r *Request) FormValue(key string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.MultipartReader">func (r *Request) MultipartReader() (*multipart.Reader, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.ParseForm">func (r *Request) ParseForm() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.ParseMultipartForm">func (r *Request) ParseMultipartForm(maxMemory int64) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.PostFormValue">func (r *Request) PostFormValue(key string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.ProtoAtLeast">func (r *Request) ProtoAtLeast(major, minor int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.Referer">func (r *Request) Referer() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.SetBasicAuth">func (r *Request) SetBasicAuth(username, password string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.UserAgent">func (r *Request) UserAgent() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.Write">func (r *Request) Write(w io.Writer) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Request.WriteProxy">func (r *Request) WriteProxy(w io.Writer) error</a></dd>
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#Response">type Response</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Get">func Get(url string) (resp *Response, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Head">func Head(url string) (resp *Response, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Post">func Post(url string, bodyType string, body io.Reader) (resp *Response, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#PostForm">func PostForm(url string, data url.Values) (resp *Response, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#ReadResponse">func ReadResponse(r *bufio.Reader, req *Request) (*Response, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Response.Cookies">func (r *Response) Cookies() []*Cookie</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Response.Location">func (r *Response) Location() (*url.URL, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Response.ProtoAtLeast">func (r *Response) ProtoAtLeast(major, minor int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Response.Write">func (r *Response) Write(w io.Writer) error</a></dd>
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#ResponseWriter">type ResponseWriter</a></dd>
				
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#RoundTripper">type RoundTripper</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#NewFileTransport">func NewFileTransport(fs FileSystem) RoundTripper</a></dd>
				
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#ServeMux">type ServeMux</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#NewServeMux">func NewServeMux() *ServeMux</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#ServeMux.Handle">func (mux *ServeMux) Handle(pattern string, handler Handler)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#ServeMux.HandleFunc">func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#ServeMux.Handler">func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#ServeMux.ServeHTTP">func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</a></dd>
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#Server">type Server</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Server.ListenAndServe">func (srv *Server) ListenAndServe() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Server.ListenAndServeTLS">func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Server.Serve">func (srv *Server) Serve(l net.Listener) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Server.SetKeepAlivesEnabled">func (s *Server) SetKeepAlivesEnabled(v bool)</a></dd>
				
			
				
				<dd><a href="https://golang-china.appspot.com/pkg/net/http/#Transport">type Transport</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Transport.CancelRequest">func (t *Transport) CancelRequest(req *Request)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Transport.CloseIdleConnections">func (t *Transport) CloseIdleConnections()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Transport.RegisterProtocol">func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang-china.appspot.com/pkg/net/http/#Transport.RoundTrip">func (t *Transport) RoundTrip(req *Request) (resp *Response, err error)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
<!--
			<h4>Examples</h4>
-->
			<h4>示例</h4>
			<dl>
			
			<dd><a class="exampleLink" href="https://golang-china.appspot.com/pkg/net/http/#example_FileServer">FileServer</a></dd>
			
			<dd><a class="exampleLink" href="https://golang-china.appspot.com/pkg/net/http/#example_FileServer_stripPrefix">FileServer (StripPrefix)</a></dd>
			
			<dd><a class="exampleLink" href="https://golang-china.appspot.com/pkg/net/http/#example_Get">Get</a></dd>
			
			<dd><a class="exampleLink" href="https://golang-china.appspot.com/pkg/net/http/#example_Hijacker">Hijacker</a></dd>
			
			<dd><a class="exampleLink" href="https://golang-china.appspot.com/pkg/net/http/#example_ServeMux_Handle">ServeMux.Handle</a></dd>
			
			<dd><a class="exampleLink" href="https://golang-china.appspot.com/pkg/net/http/#example_StripPrefix">StripPrefix</a></dd>
			
			</dl>
		</div>
		

		
<!--
			<h4>Package files</h4>
-->
			<h4>包文件</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="https://golang-china.appspot.com/src/net/http/client.go">client.go</a>
			
				<a href="https://golang-china.appspot.com/src/net/http/cookie.go">cookie.go</a>
			
				<a href="https://golang-china.appspot.com/src/net/http/doc.go">doc.go</a>
			
				<a href="https://golang-china.appspot.com/src/net/http/filetransport.go">filetransport.go</a>
			
				<a href="https://golang-china.appspot.com/src/net/http/fs.go">fs.go</a>
			
				<a href="https://golang-china.appspot.com/src/net/http/header.go">header.go</a>
			
				<a href="https://golang-china.appspot.com/src/net/http/jar.go">jar.go</a>
			
				<a href="https://golang-china.appspot.com/src/net/http/lex.go">lex.go</a>
			
				<a href="https://golang-china.appspot.com/src/net/http/request.go">request.go</a>
			
				<a href="https://golang-china.appspot.com/src/net/http/response.go">response.go</a>
			
				<a href="https://golang-china.appspot.com/src/net/http/server.go">server.go</a>
			
				<a href="https://golang-china.appspot.com/src/net/http/sniff.go">sniff.go</a>
			
				<a href="https://golang-china.appspot.com/src/net/http/status.go">status.go</a>
			
				<a href="https://golang-china.appspot.com/src/net/http/transfer.go">transfer.go</a>
			
				<a href="https://golang-china.appspot.com/src/net/http/transport.go">transport.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
<!--
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
-->
			<h2 class="toggleButton" title="点此显示内部调用图">内部调用图 ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
<!--
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
-->
			<h2 class="toggleButton" title="点此隐藏内部调用图">内部调用图 ▾</h2>
<!--
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
-->
			<p>
			在下面的调用图查看器中，每个节点都是一个属于本包的函数，其子节点即为它所调用的函数——或许是动态的。
			</p>
			<p>
			根节点为包的入口点：函数可从包的外部调用。若这些函数被其它包动态地调用，
			那么它们可能是未导出的或匿名的。
			</p>
			<p>
			点击一个节点来查看该函数的源码。在源码中，可以点击它的 <code>func</code>
			声明标记来查看其调用者。
			</p>
			<p>
			在分析特定程序或测试时，被认定为无法访问的函数会被忽略。
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
<!--
			<h2 id="pkg-constants">Constants</h2>
-->
			<h2 id="pkg-constants">常量</h2>
			
				<pre>const (
        <span id="StatusContinue">StatusContinue</span>           = 100
        <span id="StatusSwitchingProtocols">StatusSwitchingProtocols</span> = 101

        <span id="StatusOK">StatusOK</span>                   = 200
        <span id="StatusCreated">StatusCreated</span>              = 201
        <span id="StatusAccepted">StatusAccepted</span>             = 202
        <span id="StatusNonAuthoritativeInfo">StatusNonAuthoritativeInfo</span> = 203
        <span id="StatusNoContent">StatusNoContent</span>            = 204
        <span id="StatusResetContent">StatusResetContent</span>         = 205
        <span id="StatusPartialContent">StatusPartialContent</span>       = 206

        <span id="StatusMultipleChoices">StatusMultipleChoices</span>   = 300
        <span id="StatusMovedPermanently">StatusMovedPermanently</span>  = 301
        <span id="StatusFound">StatusFound</span>             = 302
        <span id="StatusSeeOther">StatusSeeOther</span>          = 303
        <span id="StatusNotModified">StatusNotModified</span>       = 304
        <span id="StatusUseProxy">StatusUseProxy</span>          = 305
        <span id="StatusTemporaryRedirect">StatusTemporaryRedirect</span> = 307

        <span id="StatusBadRequest">StatusBadRequest</span>                   = 400
        <span id="StatusUnauthorized">StatusUnauthorized</span>                 = 401
        <span id="StatusPaymentRequired">StatusPaymentRequired</span>              = 402
        <span id="StatusForbidden">StatusForbidden</span>                    = 403
        <span id="StatusNotFound">StatusNotFound</span>                     = 404
        <span id="StatusMethodNotAllowed">StatusMethodNotAllowed</span>             = 405
        <span id="StatusNotAcceptable">StatusNotAcceptable</span>                = 406
        <span id="StatusProxyAuthRequired">StatusProxyAuthRequired</span>            = 407
        <span id="StatusRequestTimeout">StatusRequestTimeout</span>               = 408
        <span id="StatusConflict">StatusConflict</span>                     = 409
        <span id="StatusGone">StatusGone</span>                         = 410
        <span id="StatusLengthRequired">StatusLengthRequired</span>               = 411
        <span id="StatusPreconditionFailed">StatusPreconditionFailed</span>           = 412
        <span id="StatusRequestEntityTooLarge">StatusRequestEntityTooLarge</span>        = 413
        <span id="StatusRequestURITooLong">StatusRequestURITooLong</span>            = 414
        <span id="StatusUnsupportedMediaType">StatusUnsupportedMediaType</span>         = 415
        <span id="StatusRequestedRangeNotSatisfiable">StatusRequestedRangeNotSatisfiable</span> = 416
        <span id="StatusExpectationFailed">StatusExpectationFailed</span>            = 417
        <span id="StatusTeapot">StatusTeapot</span>                       = 418

        <span id="StatusInternalServerError">StatusInternalServerError</span>     = 500
        <span id="StatusNotImplemented">StatusNotImplemented</span>          = 501
        <span id="StatusBadGateway">StatusBadGateway</span>              = 502
        <span id="StatusServiceUnavailable">StatusServiceUnavailable</span>      = 503
        <span id="StatusGatewayTimeout">StatusGatewayTimeout</span>          = 504
        <span id="StatusHTTPVersionNotSupported">StatusHTTPVersionNotSupported</span> = 505
)</pre>
				<p>
HTTP status codes, defined in RFC 2616.
</p>

			
				<pre>const <span id="DefaultMaxHeaderBytes">DefaultMaxHeaderBytes</span> = 1 &lt;&lt; 20 <span class="comment">// 1 MB</span>
</pre>
				<p>
DefaultMaxHeaderBytes is the maximum permitted size of the headers in an HTTP
request. This can be overridden by setting Server.MaxHeaderBytes.
</p>

			
				<pre>const <span id="DefaultMaxIdleConnsPerHost">DefaultMaxIdleConnsPerHost</span> = 2</pre>
				<p>
DefaultMaxIdleConnsPerHost is the default value of Transport's
MaxIdleConnsPerHost.
</p>

			
				<pre>const <span id="TimeFormat">TimeFormat</span> = "Mon, 02 Jan 2006 15:04:05 GMT"</pre>
				<p>
TimeFormat is the time format to use with time.Parse and time.Time.Format when
parsing or generating times in HTTP headers. It is like time.RFC1123 but hard
codes GMT as the time zone.
</p>

			
		
		
<!--
			<h2 id="pkg-variables">Variables</h2>
-->
			<h2 id="pkg-variables">变量</h2>
			
				<pre>var (
        <span id="ErrHeaderTooLong">ErrHeaderTooLong</span>        = &amp;<a href="https://golang-china.appspot.com/pkg/net/http/#ProtocolError">ProtocolError</a>{"header too long"}
        <span id="ErrShortBody">ErrShortBody</span>            = &amp;<a href="https://golang-china.appspot.com/pkg/net/http/#ProtocolError">ProtocolError</a>{"entity body too short"}
        <span id="ErrNotSupported">ErrNotSupported</span>         = &amp;<a href="https://golang-china.appspot.com/pkg/net/http/#ProtocolError">ProtocolError</a>{"feature not supported"}
        <span id="ErrUnexpectedTrailer">ErrUnexpectedTrailer</span>    = &amp;<a href="https://golang-china.appspot.com/pkg/net/http/#ProtocolError">ProtocolError</a>{"trailer header without chunked transfer encoding"}
        <span id="ErrMissingContentLength">ErrMissingContentLength</span> = &amp;<a href="https://golang-china.appspot.com/pkg/net/http/#ProtocolError">ProtocolError</a>{"missing ContentLength in HEAD response"}
        <span id="ErrNotMultipart">ErrNotMultipart</span>         = &amp;<a href="https://golang-china.appspot.com/pkg/net/http/#ProtocolError">ProtocolError</a>{"request Content-Type isn't multipart/form-data"}
        <span id="ErrMissingBoundary">ErrMissingBoundary</span>      = &amp;<a href="https://golang-china.appspot.com/pkg/net/http/#ProtocolError">ProtocolError</a>{"no multipart boundary param in Content-Type"}
)</pre>
				<p>
HTTP请求的解析错误。
</p>
<pre>var (
    ErrWriteAfterFlush = errors.New("Conn.Write called after Flush")
    ErrBodyNotAllowed  = errors.New("http: request method or response status code does not allow body")
    ErrHijacked        = errors.New("Conn has been hijacked")
    ErrContentLength   = errors.New("Conn.Write wrote more than the declared Content-Length")
)
</pre>
<p>
会被HTTP服务端返回的错误。
</p>
<pre>var DefaultClient = &amp;Client{}
</pre>
<p>
DefaultClient是用于包函数Get、Head和Post的默认Client。
</p>
<pre>var DefaultServeMux = NewServeMux()
</pre>
<p>
DefaultServeMux是用于Serve的默认ServeMux。
</p>
<pre>var ErrBodyReadAfterClose = errors.New("http: invalid Read on closed Body")
</pre>
<p>
在Resquest或Response的Body字段已经关闭后，试图从中读取时，就会返回ErrBodyReadAfterClose。这个错误一般发生在：HTTP处理器中调用完ResponseWriter
接口的WriteHeader或Write后从请求中读取数据的时候。
</p>
<pre>var ErrHandlerTimeout = errors.New("http: Handler timeout")
</pre>
<p>
在处理器超时以后调用ResponseWriter接口的Write方法，就会返回ErrHandlerTimeout。
</p>
<pre>var ErrLineTooLong = errors.New("header line too long")

var ErrMissingFile = errors.New("http: no such file")
</pre>
<p>
当请求中没有提供给FormFile函数的文件字段名，或者该字段名不是文件字段时，该函数就会返回ErrMissingFile。
</p>
<pre>var ErrNoCookie = errors.New("http: named cookie not present")

var ErrNoLocation = errors.New("http: no Location header in response")
</pre>

			
				<pre>var (
        <span id="ErrWriteAfterFlush">ErrWriteAfterFlush</span> = <a href="https://golang-china.appspot.com/pkg/errors/">errors</a>.<a href="https://golang-china.appspot.com/pkg/errors/#New">New</a>("Conn.Write called after Flush")
        <span id="ErrBodyNotAllowed">ErrBodyNotAllowed</span>  = <a href="https://golang-china.appspot.com/pkg/errors/">errors</a>.<a href="https://golang-china.appspot.com/pkg/errors/#New">New</a>("http: request method or response status code does not allow body")
        <span id="ErrHijacked">ErrHijacked</span>        = <a href="https://golang-china.appspot.com/pkg/errors/">errors</a>.<a href="https://golang-china.appspot.com/pkg/errors/#New">New</a>("Conn has been hijacked")
        <span id="ErrContentLength">ErrContentLength</span>   = <a href="https://golang-china.appspot.com/pkg/errors/">errors</a>.<a href="https://golang-china.appspot.com/pkg/errors/#New">New</a>("Conn.Write wrote more than the declared Content-Length")
)</pre>
				<p>
Errors introduced by the HTTP server.
</p>

			
				<pre>var <span id="DefaultClient">DefaultClient</span> = &amp;<a href="https://golang-china.appspot.com/pkg/net/http/#Client">Client</a>{}</pre>
				<p>
DefaultClient is the default Client and is used by Get, Head, and Post.
</p>

			
				<pre>var <span id="DefaultServeMux">DefaultServeMux</span> = <a href="https://golang-china.appspot.com/pkg/net/http/#NewServeMux">NewServeMux</a>()</pre>
				<p>
DefaultServeMux is the default ServeMux used by Serve.
</p>

			
				<pre>var <span id="ErrBodyReadAfterClose">ErrBodyReadAfterClose</span> = <a href="https://golang-china.appspot.com/pkg/errors/">errors</a>.<a href="https://golang-china.appspot.com/pkg/errors/#New">New</a>("http: invalid Read on closed Body")</pre>
				<p>
ErrBodyReadAfterClose is returned when reading a Request or Response Body after
the body has been closed. This typically happens when the body is read after an
HTTP Handler calls WriteHeader or Write on its ResponseWriter.
</p>

			
				<pre>var <span id="ErrHandlerTimeout">ErrHandlerTimeout</span> = <a href="https://golang-china.appspot.com/pkg/errors/">errors</a>.<a href="https://golang-china.appspot.com/pkg/errors/#New">New</a>("http: Handler timeout")</pre>
				<p>
ErrHandlerTimeout is returned on ResponseWriter Write calls in handlers which
have timed out.
</p>

			
				<pre>var <span id="ErrLineTooLong">ErrLineTooLong</span> = <a href="https://golang-china.appspot.com/pkg/net/http/internal/">internal</a>.<a href="https://golang-china.appspot.com/pkg/net/http/internal/#ErrLineTooLong">ErrLineTooLong</a></pre>
				<p>
ErrLineTooLong is returned when reading request or response bodies with
malformed chunked encoding.
</p>

			
				<pre>var <span id="ErrMissingFile">ErrMissingFile</span> = <a href="https://golang-china.appspot.com/pkg/errors/">errors</a>.<a href="https://golang-china.appspot.com/pkg/errors/#New">New</a>("http: no such file")</pre>
				<p>
ErrMissingFile is returned by FormFile when the provided file field name is
either not present in the request or not a file field.
</p>

			
				<pre>var <span id="ErrNoCookie">ErrNoCookie</span> = <a href="https://golang-china.appspot.com/pkg/errors/">errors</a>.<a href="https://golang-china.appspot.com/pkg/errors/#New">New</a>("http: named cookie not present")</pre>
				
			
				<pre>var <span id="ErrNoLocation">ErrNoLocation</span> = <a href="https://golang-china.appspot.com/pkg/errors/">errors</a>.<a href="https://golang-china.appspot.com/pkg/errors/#New">New</a>("http: no Location header in response")</pre>
				
			
		
		
			
			
			<h2 id="CanonicalHeaderKey">func <a href="https://golang-china.appspot.com/src/net/http/header.go?s=4465:4505#L161">CanonicalHeaderKey</a></h2>
			<pre>func CanonicalHeaderKey(s <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a></pre>
			<p>
CanonicalHeaderKey函数返回头域（表示为Header类型）的键s的规范化格式。规范化过程中让单词首字母和'-'后的第一个字母大写，其余字母小写。例如，"accept-encoding"规范化为"Accept-Encoding"。
</p>

			
			

		
			
			
			<h2 id="DetectContentType">func <a href="https://golang-china.appspot.com/src/net/http/sniff.go?s=648:690#L11">DetectContentType</a></h2>
			<pre>func DetectContentType(data []<a href="https://golang-china.appspot.com/pkg/builtin/#byte">byte</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a></pre>
			<p>
DetectContentType函数实现了http://mimesniff.spec.whatwg.org/描述的算法，用于确定数据的Content-Type。函数总是返回一个合法的MIME类型；如果它不能确定数据的类型，将返回"application/octet-stream"。它最多检查数据的前512字节。
</p>

			
			

		
			
			
			<h2 id="Error">func <a href="https://golang-china.appspot.com/src/net/http/server.go?s=38537:38589#L1317">Error</a></h2>
			<pre>func Error(w <a href="https://golang-china.appspot.com/pkg/net/http/#ResponseWriter">ResponseWriter</a>, error <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, code <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>)</pre>
			<p>
Error使用指定的错误信息和状态码回复请求，将数据写入w。错误信息必须是明文。
</p>

			
			

		
			
			
			<h2 id="Handle">func <a href="https://golang-china.appspot.com/src/net/http/server.go?s=48318:48362#L1636">Handle</a></h2>
			<pre>func Handle(pattern <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, handler <a href="https://golang-china.appspot.com/pkg/net/http/#Handler">Handler</a>)</pre>
			<p>
Handle注册HTTP处理器handler和对应的模式pattern（注册到DefaultServeMux）。如果该模式已经注册有一个处理器，Handle会panic。ServeMux的文档解释了模式的匹配机制。
</p>

			
			

		
			
			
			<h2 id="HandleFunc">func <a href="https://golang-china.appspot.com/src/net/http/server.go?s=48572:48643#L1641">HandleFunc</a></h2>
			<pre>func HandleFunc(pattern <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, handler func(<a href="https://golang-china.appspot.com/pkg/net/http/#ResponseWriter">ResponseWriter</a>, *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>))</pre>
			<p>
HandleFunc注册一个处理器函数handler和对应的模式pattern（注册到DefaultServeMux）。ServeMux的文档解释了模式的匹配机制。
</p>

			
			

		
			
			
			<h2 id="ListenAndServe">func <a href="https://golang-china.appspot.com/src/net/http/server.go?s=55192:55247#L1851">ListenAndServe</a></h2>
			<pre>func ListenAndServe(addr <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, handler <a href="https://golang-china.appspot.com/pkg/net/http/#Handler">Handler</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a></pre>
			<p>
ListenAndServe监听TCP地址addr，并且会使用handler参数调用Serve函数处理接收到的连接。handler参数一般会设为nil，此时会使用DefaultServeMux。
</p>
<p>
一个简单的服务端例子：
</p>
<pre>package main
import (
	"io"
	"net/http"
	"log"
)
// hello world, the web server
func HelloServer(w http.ResponseWriter, req *http.Request) {
	io.WriteString(w, "hello, world!\n")
}
func main() {
	http.HandleFunc("/hello", HelloServer)
	err := http.ListenAndServe(":12345", nil)
	if err != nil {
		log.Fatal("ListenAndServe: ", err)
	}
}
</pre>

			
			

		
			
			
			<h2 id="ListenAndServeTLS">func <a href="https://golang-china.appspot.com/src/net/http/server.go?s=56292:56383#L1884">ListenAndServeTLS</a></h2>
			<pre>func ListenAndServeTLS(addr <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, certFile <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, keyFile <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, handler <a href="https://golang-china.appspot.com/pkg/net/http/#Handler">Handler</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a></pre>
			<p>
ListenAndServeTLS函数和ListenAndServe函数的行为基本一致，除了它期望HTTPS连接之外。此外，必须提供证书文件和对应的私钥文件。如果证书是由权威机构签发的，certFile参数必须是顺序串联的服务端证书和CA证书。如果srv.Addr为空字符串，会使用":https"。
</p>
<p>
一个简单的服务端例子：
</p>
<pre>import (
	"log"
	"net/http"
)
func handler(w http.ResponseWriter, req *http.Request) {
	w.Header().Set("Content-Type", "text/plain")
	w.Write([]byte("This is an example server.\n"))
}
func main() {
	http.HandleFunc("/", handler)
	log.Printf("About to listen on 10443. Go to <a href="https://127.0.0.1:10443/">https://127.0.0.1:10443/</a>")
	err := http.ListenAndServeTLS(":10443", "cert.pem", "key.pem", nil)
	if err != nil {
		log.Fatal(err)
	}
}
</pre>
<p>
程序员可以使用crypto/tls包的generate_cert.go文件来生成cert.pem和key.pem两个文件。
</p>

			
			

		
			
			
			<h2 id="MaxBytesReader">func <a href="https://golang-china.appspot.com/src/net/http/request.go?s=21718:21795#L696">MaxBytesReader</a></h2>
			<pre>func MaxBytesReader(w <a href="https://golang-china.appspot.com/pkg/net/http/#ResponseWriter">ResponseWriter</a>, r <a href="https://golang-china.appspot.com/pkg/io/">io</a>.<a href="https://golang-china.appspot.com/pkg/io/#ReadCloser">ReadCloser</a>, n <a href="https://golang-china.appspot.com/pkg/builtin/#int64">int64</a>) <a href="https://golang-china.appspot.com/pkg/io/">io</a>.<a href="https://golang-china.appspot.com/pkg/io/#ReadCloser">ReadCloser</a></pre>
			<p>
MaxBytesReader类似io.LimitReader，但它是用来限制接收到的请求的Body的大小的。不同于io.LimitReader，本函数返回一个ReadCloser，返回值的Read方法在读取的数据超过大小限制时会返回非EOF错误，其Close方法会关闭下层的io.ReadCloser接口r。
</p>
<p>
MaxBytesReader预防客户端因为意外或者蓄意发送的“大”请求，以避免尺寸过大的请求浪费服务端资源。
</p>

			
			

		
			
			
			<h2 id="NotFound">func <a href="https://golang-china.appspot.com/src/net/http/server.go?s=38770:38813#L1324">NotFound</a></h2>
			<pre>func NotFound(w <a href="https://golang-china.appspot.com/pkg/net/http/#ResponseWriter">ResponseWriter</a>, r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>)</pre>
			<p>
NotFound回复请求404状态码（not found：目标未发现）。
</p>

			
			

		
			
			
			<h2 id="ParseHTTPVersion">func <a href="https://golang-china.appspot.com/src/net/http/request.go?s=15319:15381#L469">ParseHTTPVersion</a></h2>
			<pre>func ParseHTTPVersion(vers <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) (major, minor <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>, ok <a href="https://golang-china.appspot.com/pkg/builtin/#bool">bool</a>)</pre>
			<p>
ParseHTTPVersion解析HTTP版本字符串。如"HTTP/1.0"返回(1, 0, true)。
</p>

			
			

		
			
			
			<h2 id="ParseTime">func <a href="https://golang-china.appspot.com/src/net/http/header.go?s=1908:1960#L69">ParseTime</a></h2>
			<pre>func ParseTime(text <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) (t <a href="https://golang-china.appspot.com/pkg/time/">time</a>.<a href="https://golang-china.appspot.com/pkg/time/#Time">Time</a>, err <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
			<p>
ParseTime用3种格式TimeFormat,
time.RFC850和time.ANSIC尝试解析一个时间头的值（如Date: header）。
</p>

			
			

		
			
			
			<h2 id="ProxyFromEnvironment">func <a href="https://golang-china.appspot.com/src/net/http/transport.go?s=4805:4862#L126">ProxyFromEnvironment</a></h2>
			<pre>func ProxyFromEnvironment(req *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) (*<a href="https://golang-china.appspot.com/pkg/net/url/">url</a>.<a href="https://golang-china.appspot.com/pkg/net/url/#URL">URL</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
			<p>
ProxyFromEnvironment使用环境变量$HTTP_PROXY和$NO_PROXY(或$http_proxy和$no_proxy)的配置返回用于req的代理。如果代理环境不合法将返回错误；如果环境未设定代理或者给定的request不应使用代理时，将返回(nil,
nil)；如果req.URL.Host字段是"localhost"（可以有端口号，也可以没有），也会返回(nil, nil)。
</p>

			
			

		
			
			
			<h2 id="ProxyURL">func <a href="https://golang-china.appspot.com/src/net/http/transport.go?s=5664:5729#L157">ProxyURL</a></h2>
			<pre>func ProxyURL(fixedURL *<a href="https://golang-china.appspot.com/pkg/net/url/">url</a>.<a href="https://golang-china.appspot.com/pkg/net/url/#URL">URL</a>) func(*<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) (*<a href="https://golang-china.appspot.com/pkg/net/url/">url</a>.<a href="https://golang-china.appspot.com/pkg/net/url/#URL">URL</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
			<p>
ProxyURL返回一个代理函数（用于Transport类型），该函数总是返回同一个URL。
</p>

			
			

		
			
			
			<h2 id="Redirect">func <a href="https://golang-china.appspot.com/src/net/http/server.go?s=39737:39805#L1351">Redirect</a></h2>
			<pre>func Redirect(w <a href="https://golang-china.appspot.com/pkg/net/http/#ResponseWriter">ResponseWriter</a>, r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>, urlStr <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, code <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>)</pre>
			<p>
Redirect回复请求一个重定向地址urlStr和状态码code。该重定向地址可以是相对于请求r的相对地址。
</p>

			
			

		
			
			
			<h2 id="Serve">func <a href="https://golang-china.appspot.com/src/net/http/server.go?s=48956:49005#L1649">Serve</a></h2>
			<pre>func Serve(l <a href="https://golang-china.appspot.com/pkg/net/">net</a>.<a href="https://golang-china.appspot.com/pkg/net/#Listener">Listener</a>, handler <a href="https://golang-china.appspot.com/pkg/net/http/#Handler">Handler</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a></pre>
			<p>
Serve会接手监听器l收到的每一个连接，并为每一个连接创建一个新的服务go程。该go程会读取请求，然后调用handler回复请求。handler参数一般会设为nil，此时会使用DefaultServeMux。
</p>

			
			

		
			
			
			<h2 id="ServeContent">func <a href="https://golang-china.appspot.com/src/net/http/fs.go?s=3535:3639#L107">ServeContent</a></h2>
			<pre>func ServeContent(w <a href="https://golang-china.appspot.com/pkg/net/http/#ResponseWriter">ResponseWriter</a>, req *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>, name <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, modtime <a href="https://golang-china.appspot.com/pkg/time/">time</a>.<a href="https://golang-china.appspot.com/pkg/time/#Time">Time</a>, content <a href="https://golang-china.appspot.com/pkg/io/">io</a>.<a href="https://golang-china.appspot.com/pkg/io/#ReadSeeker">ReadSeeker</a>)</pre>
			<p>
ServeContent使用提供的ReadSeeker的内容回复请求。ServeContent比起io.Copy函数的主要优点，是可以处理范围类请求（只要一部分内容）、设置MIME类型，处理If-Modified-Since请求。
</p>
<p>
如果未设定回复的Content-Type头，本函数首先会尝试从name的文件扩展名推断数据类型；如果失败，会用读取content的第1块数据并提供给DetectContentType推断类型；之后会设置Content-Type头。参数name不会用于别的地方，甚至于它可以是空字符串，也永远不会发送到回复里。
</p>
<p>
如果modtime不是Time零值，函数会在回复的头域里设置Last-Modified头。如果请求的头域包含If-Modified-Since头，本函数会使用modtime参数来确定是否应该发送内容。如果调用者设置了w的ETag头，ServeContent会使用它处理包含If-Range头和If-None-Match头的请求。
</p>
<p>
参数content的Seek方法必须有效：函数使用Seek来确定它的大小。
</p>
<p>
注意：本包File接口和*os.File类型都实现了io.ReadSeeker接口。
</p>

			
			

		
			
			
			<h2 id="ServeFile">func <a href="https://golang-china.appspot.com/src/net/http/fs.go?s=13941:13998#L443">ServeFile</a></h2>
			<pre>func ServeFile(w <a href="https://golang-china.appspot.com/pkg/net/http/#ResponseWriter">ResponseWriter</a>, r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>, name <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>)</pre>
			<p>
ServeFile回复请求name指定的文件或者目录的内容。
</p>

			
			

		
			
			
			<h2 id="SetCookie">func <a href="https://golang-china.appspot.com/src/net/http/cookie.go?s=2945:2993#L119">SetCookie</a></h2>
			<pre>func SetCookie(w <a href="https://golang-china.appspot.com/pkg/net/http/#ResponseWriter">ResponseWriter</a>, cookie *<a href="https://golang-china.appspot.com/pkg/net/http/#Cookie">Cookie</a>)</pre>
			<p>
SetCookie在w的头域中添加Set-Cookie头，该HTTP头的值为cookie。
</p>

			
			

		
			
			
			<h2 id="StatusText">func <a href="https://golang-china.appspot.com/src/net/http/status.go?s=4602:4634#L108">StatusText</a></h2>
			<pre>func StatusText(code <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a></pre>
			<p>
StatusText返回HTTP状态码code对应的文本，如220对应"OK"。如果code是未知的状态码，会返回""。
</p>

			
			

		
		
			
			
			<h2 id="Client">type <a href="https://golang-china.appspot.com/src/net/http/client.go?s=897:2420#L26">Client</a></h2>
			<pre>type Client struct {
        <span class="comment">// Transport specifies the mechanism by which individual</span>
        <span class="comment">// HTTP requests are made.</span>
        <span class="comment">// If nil, DefaultTransport is used.</span>
        Transport <a href="https://golang-china.appspot.com/pkg/net/http/#RoundTripper">RoundTripper</a>

        <span class="comment">// CheckRedirect specifies the policy for handling redirects.</span>
        <span class="comment">// If CheckRedirect is not nil, the client calls it before</span>
        <span class="comment">// following an HTTP redirect. The arguments req and via are</span>
        <span class="comment">// the upcoming request and the requests made already, oldest</span>
        <span class="comment">// first. If CheckRedirect returns an error, the Client's Get</span>
        <span class="comment">// method returns both the previous Response and</span>
        <span class="comment">// CheckRedirect's error (wrapped in a url.Error) instead of</span>
        <span class="comment">// issuing the Request req.</span>
        <span class="comment">//</span>
        <span class="comment">// If CheckRedirect is nil, the Client uses its default policy,</span>
        <span class="comment">// which is to stop after 10 consecutive requests.</span>
        CheckRedirect func(req *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>, via []*<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>

        <span class="comment">// Jar specifies the cookie jar.</span>
        <span class="comment">// If Jar is nil, cookies are not sent in requests and ignored</span>
        <span class="comment">// in responses.</span>
        Jar <a href="https://golang-china.appspot.com/pkg/net/http/#CookieJar">CookieJar</a>

        <span class="comment">// Timeout specifies a time limit for requests made by this</span>
        <span class="comment">// Client. The timeout includes connection time, any</span>
        <span class="comment">// redirects, and reading the response body. The timer remains</span>
        <span class="comment">// running after Get, Head, Post, or Do return and will</span>
        <span class="comment">// interrupt reading of the Response.Body.</span>
        <span class="comment">//</span>
        <span class="comment">// A Timeout of zero means no timeout.</span>
        <span class="comment">//</span>
        <span class="comment">// The Client's Transport must support the CancelRequest</span>
        <span class="comment">// method or Client will return errors when attempting to make</span>
        <span class="comment">// a request with Get, Head, Post, or Do. Client's default</span>
        <span class="comment">// Transport (DefaultTransport) supports CancelRequest.</span>
        Timeout <a href="https://golang-china.appspot.com/pkg/time/">time</a>.<a href="https://golang-china.appspot.com/pkg/time/#Duration">Duration</a>
}</pre>
			<p>
Client类型代表HTTP客户端。它的零值（DefaultClient）是一个可用的使用DefaultTransport的客户端。
</p>
<p>
Client的Transport字段一般会含有内部状态（缓存TCP连接），因此Client类型值应尽量被重用而不是每次需要都创建新的。Client类型值可以安全的被多个go程同时使用。
</p>
<p>
Client类型的层次比RoundTripper接口（如Transport）高，还会管理HTTP的cookie和重定向等细节。
</p>


			

			

			
			
			

			

			
				
				<h3 id="Client.Do">func (*Client) <a href="https://golang-china.appspot.com/src/net/http/client.go?s=6009:6070#L163">Do</a></h3>
				<pre>func (c *<a href="https://golang-china.appspot.com/pkg/net/http/#Client">Client</a>) Do(req *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) (resp *<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>, err <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
Do方法发送请求，返回HTTP回复。它会遵守客户端c设置的策略（如重定向、cookie、认证）。
</p>
<p>
如果客户端的策略（如重定向）返回错误或存在HTTP协议错误时，本方法将返回该错误；如果回应的状态码不是2xx，本方法并不会返回错误。
</p>
<p>
如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。如果返回值resp的主体未关闭，c下层的RoundTripper接口（一般为Transport类型）可能无法重用resp主体下层保持的TCP连接去执行之后的请求。
</p>
<p>
请求的主体，如果非nil，会在执行后被c.Transport关闭，即使出现错误。
</p>
<p>
一般应使用Get、Post或PostForm方法代替Do方法。
</p>

				
				
				
			
				
				<h3 id="Client.Get">func (*Client) <a href="https://golang-china.appspot.com/src/net/http/client.go?s=9887:9947#L291">Get</a></h3>
				<pre>func (c *<a href="https://golang-china.appspot.com/pkg/net/http/#Client">Client</a>) Get(url <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) (resp *<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>, err <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
Get向指定的URL发出一个GET请求，如果回应的状态码如下，Get会在调用c.CheckRedirect后执行重定向：
</p>
<pre>301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
</pre>
<p>
如果c.CheckRedirect执行失败或存在HTTP协议错误时，本方法将返回该错误；如果回应的状态码不是2xx，本方法并不会返回错误。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。
</p>

				
				
				
			
				
				<h3 id="Client.Head">func (*Client) <a href="https://golang-china.appspot.com/src/net/http/client.go?s=16251:16312#L512">Head</a></h3>
				<pre>func (c *<a href="https://golang-china.appspot.com/pkg/net/http/#Client">Client</a>) Head(url <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) (resp *<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>, err <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
Head向指定的URL发出一个HEAD请求，如果回应的状态码如下，Head会在调用c.CheckRedirect后执行重定向：
</p>
<pre>301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
</pre>

				
				
				
			
				
				<h3 id="Client.Post">func (*Client) <a href="https://golang-china.appspot.com/src/net/http/client.go?s=14155:14249#L455">Post</a></h3>
				<pre>func (c *<a href="https://golang-china.appspot.com/pkg/net/http/#Client">Client</a>) Post(url <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, bodyType <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, body <a href="https://golang-china.appspot.com/pkg/io/">io</a>.<a href="https://golang-china.appspot.com/pkg/io/#Reader">Reader</a>) (resp *<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>, err <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
Post向指定的URL发出一个POST请求。bodyType为POST数据的类型，
body为POST数据，作为请求的主体。如果参数body实现了io.Closer接口，它会在发送请求后被关闭。调用者有责任在读取完返回值resp的主体后关闭它。
</p>

				
				
				
			
				
				<h3 id="Client.PostForm">func (*Client) <a href="https://golang-china.appspot.com/src/net/http/client.go?s=15359:15441#L486">PostForm</a></h3>
				<pre>func (c *<a href="https://golang-china.appspot.com/pkg/net/http/#Client">Client</a>) PostForm(url <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, data <a href="https://golang-china.appspot.com/pkg/net/url/">url</a>.<a href="https://golang-china.appspot.com/pkg/net/url/#Values">Values</a>) (resp *<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>, err <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
PostForm向指定的URL发出一个POST请求，url.Values类型的data会被编码为请求的主体。POST数据的类型一般会设为"application/x-www-form-urlencoded"。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。
</p>

				
				
				
			
		
			
			
			<h2 id="CloseNotifier">type <a href="https://golang-china.appspot.com/src/net/http/server.go?s=3702:3870#L100">CloseNotifier</a></h2>
			<pre>type CloseNotifier interface {
        <span class="comment">// CloseNotify returns a channel that receives a single value</span>
        <span class="comment">// when the client connection has gone away.</span>
        CloseNotify() &lt;-chan <a href="https://golang-china.appspot.com/pkg/builtin/#bool">bool</a>
}</pre>
			<p>
HTTP处理器ResponseWriter接口参数的下层如果实现了CloseNotifier接口，可以让用户检测下层的连接是否停止。如果客户端在回复准备好之前关闭了连接，该机制可以用于取消服务端耗时较长的操作。
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="ConnState">type <a href="https://golang-china.appspot.com/src/net/http/server.go?s=50799:50817#L1689">ConnState</a></h2>
			<pre>type ConnState <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a></pre>
			<p>
ConnState代表一个客户端到服务端的连接的状态。本类型用于可选的Server.ConnState回调函数。
</p>
<pre>const (
    // StateNew代表一个新的连接，将要立刻发送请求。
    // 连接从这个状态开始，然后转变为StateAlive或StateClosed。
    StateNew ConnState = iota
    // StateActive代表一个已经读取了请求数据1到多个字节的连接。
    // 用于StateAlive的Server.ConnState回调函数在将连接交付给处理器之前被触发，
    // 等到请求被处理完后，Server.ConnState回调函数再次被触发。
    // 在请求被处理后，连接状态改变为StateClosed、StateHijacked或StateIdle。
    StateActive
    // StateIdle代表一个已经处理完了请求、处在闲置状态、等待新请求的连接。
    // 连接状态可以从StateIdle改变为StateActive或StateClosed。
    StateIdle
    // 代表一个被劫持的连接。这是一个终止状态，不会转变为StateClosed。
    StateHijacked
    // StateClosed代表一个关闭的连接。
    // 这是一个终止状态。被劫持的连接不会转变为StateClosed。
    StateClosed
)
</pre>


			
				<pre>const (
        <span class="comment">// StateNew represents a new connection that is expected to</span>
        <span class="comment">// send a request immediately. Connections begin at this</span>
        <span class="comment">// state and then transition to either StateActive or</span>
        <span class="comment">// StateClosed.</span>
        <span id="StateNew">StateNew</span> <a href="https://golang-china.appspot.com/pkg/net/http/#ConnState">ConnState</a> = <a href="https://golang-china.appspot.com/pkg/builtin/#iota">iota</a>

        <span class="comment">// StateActive represents a connection that has read 1 or more</span>
        <span class="comment">// bytes of a request. The Server.ConnState hook for</span>
        <span class="comment">// StateActive fires before the request has entered a handler</span>
        <span class="comment">// and doesn't fire again until the request has been</span>
        <span class="comment">// handled. After the request is handled, the state</span>
        <span class="comment">// transitions to StateClosed, StateHijacked, or StateIdle.</span>
        <span id="StateActive">StateActive</span>

        <span class="comment">// StateIdle represents a connection that has finished</span>
        <span class="comment">// handling a request and is in the keep-alive state, waiting</span>
        <span class="comment">// for a new request. Connections transition from StateIdle</span>
        <span class="comment">// to either StateActive or StateClosed.</span>
        <span id="StateIdle">StateIdle</span>

        <span class="comment">// StateHijacked represents a hijacked connection.</span>
        <span class="comment">// This is a terminal state. It does not transition to StateClosed.</span>
        <span id="StateHijacked">StateHijacked</span>

        <span class="comment">// StateClosed represents a closed connection.</span>
        <span class="comment">// This is a terminal state. Hijacked connections do not</span>
        <span class="comment">// transition to StateClosed.</span>
        <span id="StateClosed">StateClosed</span>
)</pre>
				
			

			

			
			
			

			

			
				
				<h3 id="ConnState.String">func (ConnState) <a href="https://golang-china.appspot.com/src/net/http/server.go?s=52101:52135#L1730">String</a></h3>
				<pre>func (c <a href="https://golang-china.appspot.com/pkg/net/http/#ConnState">ConnState</a>) String() <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Cookie">type <a href="https://golang-china.appspot.com/src/net/http/cookie.go?s=480:929#L13">Cookie</a></h2>
			<pre>type Cookie struct {
        Name       <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>
        Value      <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>
        Path       <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>
        Domain     <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>
        Expires    <a href="https://golang-china.appspot.com/pkg/time/">time</a>.<a href="https://golang-china.appspot.com/pkg/time/#Time">Time</a>
        RawExpires <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>

        <span class="comment">// MaxAge=0 means no 'Max-Age' attribute specified.</span>
        <span class="comment">// MaxAge&lt;0 means delete cookie now, equivalently 'Max-Age: 0'</span>
        <span class="comment">// MaxAge&gt;0 means Max-Age attribute present and given in seconds</span>
        MaxAge   <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>
        Secure   <a href="https://golang-china.appspot.com/pkg/builtin/#bool">bool</a>
        HttpOnly <a href="https://golang-china.appspot.com/pkg/builtin/#bool">bool</a>
        Raw      <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>
        Unparsed []<a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a> <span class="comment">// Raw text of unparsed attribute-value pairs</span>
}</pre>
			<p>
Cookie代表一个出现在HTTP回复的头域中Set-Cookie头的值里或者HTTP请求的头域中Cookie头的值里的HTTP cookie。
</p>


			

			

			
			
			

			

			
				
				<h3 id="Cookie.String">func (*Cookie) <a href="https://golang-china.appspot.com/src/net/http/cookie.go?s=3221:3253#L126">String</a></h3>
				<pre>func (c *<a href="https://golang-china.appspot.com/pkg/net/http/#Cookie">Cookie</a>) String() <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a></pre>
				<p>
String返回该cookie的序列化结果。如果只设置了Name和Value字段，序列化结果可用于HTTP请求的Cookie头或者HTTP回复的Set-Cookie头；如果设置了其他字段，序列化结果只能用于HTTP回复的Set-Cookie头。
</p>

				
				
				
			
		
			
			
			<h2 id="CookieJar">type <a href="https://golang-china.appspot.com/src/net/http/jar.go?s=433:899#L7">CookieJar</a></h2>
			<pre>type CookieJar interface {
        <span class="comment">// SetCookies handles the receipt of the cookies in a reply for the</span>
        <span class="comment">// given URL.  It may or may not choose to save the cookies, depending</span>
        <span class="comment">// on the jar's policy and implementation.</span>
        SetCookies(u *<a href="https://golang-china.appspot.com/pkg/net/url/">url</a>.<a href="https://golang-china.appspot.com/pkg/net/url/#URL">URL</a>, cookies []*<a href="https://golang-china.appspot.com/pkg/net/http/#Cookie">Cookie</a>)

        <span class="comment">// Cookies returns the cookies to send in a request for the given URL.</span>
        <span class="comment">// It is up to the implementation to honor the standard cookie use</span>
        <span class="comment">// restrictions such as in RFC 6265.</span>
        Cookies(u *<a href="https://golang-china.appspot.com/pkg/net/url/">url</a>.<a href="https://golang-china.appspot.com/pkg/net/url/#URL">URL</a>) []*<a href="https://golang-china.appspot.com/pkg/net/http/#Cookie">Cookie</a>
}</pre>
			<p>
CookieJar管理cookie的存储和在HTTP请求中的使用。CookieJar的实现必须能安全的被多个go程同时使用。
</p>
<p>
net/http/cookiejar包提供了一个CookieJar的实现。
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Dir">type <a href="https://golang-china.appspot.com/src/net/http/fs.go?s=719:734#L23">Dir</a></h2>
			<pre>type Dir <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a></pre>
			<p>
Dir使用限制到指定目录树的本地文件系统实现了http.FileSystem接口。空Dir被视为"."，即代表当前目录。
</p>


			

			

			
			
			

			

			
				
				<h3 id="Dir.Open">func (Dir) <a href="https://golang-china.appspot.com/src/net/http/fs.go?s=736:780#L25">Open</a></h3>
				<pre>func (d <a href="https://golang-china.appspot.com/pkg/net/http/#Dir">Dir</a>) Open(name <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) (<a href="https://golang-china.appspot.com/pkg/net/http/#File">File</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="File">type <a href="https://golang-china.appspot.com/src/net/http/fs.go?s=1591:1755#L52">File</a></h2>
			<pre>type File interface {
        <a href="https://golang-china.appspot.com/pkg/io/">io</a>.<a href="https://golang-china.appspot.com/pkg/io/#Closer">Closer</a>
        <a href="https://golang-china.appspot.com/pkg/io/">io</a>.<a href="https://golang-china.appspot.com/pkg/io/#Reader">Reader</a>
        Readdir(count <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>) ([]<a href="https://golang-china.appspot.com/pkg/os/">os</a>.<a href="https://golang-china.appspot.com/pkg/os/#FileInfo">FileInfo</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)
        Seek(offset <a href="https://golang-china.appspot.com/pkg/builtin/#int64">int64</a>, whence <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>) (<a href="https://golang-china.appspot.com/pkg/builtin/#int64">int64</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)
        Stat() (<a href="https://golang-china.appspot.com/pkg/os/">os</a>.<a href="https://golang-china.appspot.com/pkg/os/#FileInfo">FileInfo</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)
}</pre>
			<p>
File是被FileSystem接口的Open方法返回的接口类型，可以被FileServer等函数用于文件访问服务。
</p>
<p>
该接口的方法的行为应该和*os.File类型的同名方法相同。
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="FileSystem">type <a href="https://golang-china.appspot.com/src/net/http/fs.go?s=1354:1416#L44">FileSystem</a></h2>
			<pre>type FileSystem interface {
        Open(name <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) (<a href="https://golang-china.appspot.com/pkg/net/http/#File">File</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)
}</pre>
			<p>
FileSystem接口实现了对一系列命名文件的访问。文件路径的分隔符为'/'，不管主机操作系统的惯例如何。
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Flusher">type <a href="https://golang-china.appspot.com/src/net/http/server.go?s=2907:2991#L79">Flusher</a></h2>
			<pre>type Flusher interface {
        <span class="comment">// Flush sends any buffered data to the client.</span>
        Flush()
}</pre>
			<p>
HTTP处理器ResponseWriter接口参数的下层如果实现了Flusher接口，可以让HTTP处理器将缓冲中的数据发送到客户端。
</p>
<p>
注意：即使ResponseWriter接口的下层支持Flush方法，如果客户端是通过HTTP代理连接的，缓冲中的数据也可能直到回复完毕才被传输到客户端。
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Handler">type <a href="https://golang-china.appspot.com/src/net/http/server.go?s=1361:1424#L42">Handler</a></h2>
			<pre>type Handler interface {
        ServeHTTP(<a href="https://golang-china.appspot.com/pkg/net/http/#ResponseWriter">ResponseWriter</a>, *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>)
}</pre>
			<p>
实现了Handler接口的对象可以注册到HTTP服务端，为特定的路径及其子树提供服务。
</p>
<p>
ServeHTTP应该将回复的头域和数据写入ResponseWriter接口然后返回。返回标志着该请求已经结束，HTTP服务端可以转移向该连接上的下一个请求。
</p>


			

			

			
			
			

			
				
				<h3 id="FileServer">func <a href="https://golang-china.appspot.com/src/net/http/fs.go?s=14534:14574#L463">FileServer</a></h3>
				<pre>func FileServer(root <a href="https://golang-china.appspot.com/pkg/net/http/#FileSystem">FileSystem</a>) <a href="https://golang-china.appspot.com/pkg/net/http/#Handler">Handler</a></pre>
				<p>
FileServer返回一个使用FileSystem接口root提供文件访问服务的HTTP处理器。要使用操作系统的FileSystem接口实现，可使用http.Dir：
</p>
<pre>http.Handle("/", http.FileServer(http.Dir("/tmp")))
</pre>

				<div id="example_FileServer" class="toggle">
	<div class="collapsed">
<!--
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
-->
		<p class="exampleHeading toggleButton">▹ <span class="text">示例</span></p>
	</div>
	<div class="expanded">
<!--
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
-->
		<p class="exampleHeading toggleButton">▾ <span class="text">示例</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code">package main

import (
	"log"
	"net/http"
)

func main() {
	// Simple static webserver:
	log.Fatal(http.ListenAndServe(":8080", http.FileServer(http.Dir("/usr/share/doc"))))
}
</textarea></div>
				<div class="output"><pre></pre></div>
				<div class="buttons">
<!--
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					<a class="share" title="Share this code">Share</a>
-->
					<a class="run" title="运行此代码[Shift+Enter]">运行</a>
					<a class="fmt" title="格式化此代码">格式化</a>
					<a class="share" title="分享此代码">分享</a>
				</div>
			</div>
		
	</div>
</div>
<div id="example_FileServer_stripPrefix" class="toggle">
	<div class="collapsed">
<!--
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (StripPrefix)</span></p>
-->
		<p class="exampleHeading toggleButton">▹ <span class="text">示例 (StripPrefix)</span></p>
	</div>
	<div class="expanded">
<!--
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (StripPrefix)</span></p>
-->
		<p class="exampleHeading toggleButton">▾ <span class="text">示例 (StripPrefix)</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code">package main

import (
	"net/http"
)

func main() {
	// To serve a directory on disk (/tmp) under an alternate URL
	// path (/tmpfiles/), use StripPrefix to modify the request
	// URL's path before the FileServer sees it:
	http.Handle("/tmpfiles/", http.StripPrefix("/tmpfiles/", http.FileServer(http.Dir("/tmp"))))
}
</textarea></div>
				<div class="output"><pre></pre></div>
				<div class="buttons">
<!--
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					<a class="share" title="Share this code">Share</a>
-->
					<a class="run" title="运行此代码[Shift+Enter]">运行</a>
					<a class="fmt" title="格式化此代码">格式化</a>
					<a class="share" title="分享此代码">分享</a>
				</div>
			</div>
		
	</div>
</div>

				
			
				
				<h3 id="NotFoundHandler">func <a href="https://golang-china.appspot.com/src/net/http/server.go?s=38987:39017#L1328">NotFoundHandler</a></h3>
				<pre>func NotFoundHandler() <a href="https://golang-china.appspot.com/pkg/net/http/#Handler">Handler</a></pre>
				<p>
NotFoundHandler返回一个简单的请求处理器，该处理器会对每个请求都回复"404 page not found"。
</p>

				
				
			
				
				<h3 id="RedirectHandler">func <a href="https://golang-china.appspot.com/src/net/http/server.go?s=42171:42221#L1435">RedirectHandler</a></h3>
				<pre>func RedirectHandler(url <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, code <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>) <a href="https://golang-china.appspot.com/pkg/net/http/#Handler">Handler</a></pre>
				<p>
RedirectHandler返回一个请求处理器，该处理器会对每个请求都使用状态码code重定向到网址url。
</p>

				
				
			
				
				<h3 id="StripPrefix">func <a href="https://golang-china.appspot.com/src/net/http/server.go?s=39326:39376#L1335">StripPrefix</a></h3>
				<pre>func StripPrefix(prefix <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, h <a href="https://golang-china.appspot.com/pkg/net/http/#Handler">Handler</a>) <a href="https://golang-china.appspot.com/pkg/net/http/#Handler">Handler</a></pre>
				<p>
StripPrefix返回一个处理器，该处理器会将请求的URL.Path字段中给定前缀prefix去除后再交由h处理。StripPrefix会向URL.Path字段中没有给定前缀的请求回复404
page not found。
</p>

				<div id="example_StripPrefix" class="toggle">
	<div class="collapsed">
<!--
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
-->
		<p class="exampleHeading toggleButton">▹ <span class="text">示例</span></p>
	</div>
	<div class="expanded">
<!--
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
-->
		<p class="exampleHeading toggleButton">▾ <span class="text">示例</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code">package main

import (
	"net/http"
)

func main() {
	// To serve a directory on disk (/tmp) under an alternate URL
	// path (/tmpfiles/), use StripPrefix to modify the request
	// URL's path before the FileServer sees it:
	http.Handle("/tmpfiles/", http.StripPrefix("/tmpfiles/", http.FileServer(http.Dir("/tmp"))))
}
</textarea></div>
				<div class="output"><pre></pre></div>
				<div class="buttons">
<!--
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					<a class="share" title="Share this code">Share</a>
-->
					<a class="run" title="运行此代码[Shift+Enter]">运行</a>
					<a class="fmt" title="格式化此代码">格式化</a>
					<a class="share" title="分享此代码">分享</a>
				</div>
			</div>
		
	</div>
</div>

				
			
				
				<h3 id="TimeoutHandler">func <a href="https://golang-china.appspot.com/src/net/http/server.go?s=58031:58099#L1935">TimeoutHandler</a></h3>
				<pre>func TimeoutHandler(h <a href="https://golang-china.appspot.com/pkg/net/http/#Handler">Handler</a>, dt <a href="https://golang-china.appspot.com/pkg/time/">time</a>.<a href="https://golang-china.appspot.com/pkg/time/#Duration">Duration</a>, msg <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) <a href="https://golang-china.appspot.com/pkg/net/http/#Handler">Handler</a></pre>
				<p>
TimeoutHandler返回一个采用指定时间限制的请求处理器。
</p>
<p>
返回的Handler会调用h.ServeHTTP去处理每个请求，但如果某一次调用耗时超过了时间限制，该处理器会回复请求状态码503 Service
Unavailable，并将msg作为回复的主体（如果msg为空字符串，将发送一个合理的默认信息）。在超时后，h对它的ResponseWriter接口参数的写入操作会返回ErrHandlerTimeout。
</p>

				
				
			

			
		
			
			
			<h2 id="HandlerFunc">type <a href="https://golang-china.appspot.com/src/net/http/server.go?s=38242:38289#L1306">HandlerFunc</a></h2>
			<pre>type HandlerFunc func(<a href="https://golang-china.appspot.com/pkg/net/http/#ResponseWriter">ResponseWriter</a>, *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>)</pre>
			<p>
HandlerFunc
type是一个适配器，通过类型转换让我们可以将普通的函数作为HTTP处理器使用。如果f是一个具有适当签名的函数，HandlerFunc(f)通过调用f实现了Handler接口。
</p>


			

			

			
			
			

			

			
				
				<h3 id="HandlerFunc.ServeHTTP">func (HandlerFunc) <a href="https://golang-china.appspot.com/src/net/http/server.go?s=38319:38379#L1309">ServeHTTP</a></h3>
				<pre>func (f <a href="https://golang-china.appspot.com/pkg/net/http/#HandlerFunc">HandlerFunc</a>) ServeHTTP(w <a href="https://golang-china.appspot.com/pkg/net/http/#ResponseWriter">ResponseWriter</a>, r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>)</pre>
				<p>
ServeHTTP方法会调用f(w, r)
</p>

				
				
				
			
		
			
			
			<h2 id="Header">type <a href="https://golang-china.appspot.com/src/net/http/header.go?s=350:381#L9">Header</a></h2>
			<pre>type Header map[<a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>][]<a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a></pre>
			<p>
Header代表HTTP头域的键值对。
</p>


			

			

			
			
			

			

			
				
				<h3 id="Header.Add">func (Header) <a href="https://golang-china.appspot.com/src/net/http/header.go?s=488:526#L13">Add</a></h3>
				<pre>func (h <a href="https://golang-china.appspot.com/pkg/net/http/#Header">Header</a>) Add(key, value <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>)</pre>
				<p>
Add添加键值对到h，如键已存在则会将新的值附加到旧值切片后面。
</p>

				
				
				
			
				
				<h3 id="Header.Del">func (Header) <a href="https://golang-china.appspot.com/src/net/http/header.go?s=1321:1352#L41">Del</a></h3>
				<pre>func (h <a href="https://golang-china.appspot.com/pkg/net/http/#Header">Header</a>) Del(key <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>)</pre>
				<p>
Del删除键值对。
</p>

				
				
				
			
				
				<h3 id="Header.Get">func (Header) <a href="https://golang-china.appspot.com/src/net/http/header.go?s=1015:1053#L28">Get</a></h3>
				<pre>func (h <a href="https://golang-china.appspot.com/pkg/net/http/#Header">Header</a>) Get(key <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a></pre>
				<p>
Get返回键对应的第一个值，如果键不存在会返回""。如要获取该键对应的值切片，请直接用规范格式的键访问map。
</p>

				
				
				
			
				
				<h3 id="Header.Set">func (Header) <a href="https://golang-china.appspot.com/src/net/http/header.go?s=713:751#L20">Set</a></h3>
				<pre>func (h <a href="https://golang-china.appspot.com/pkg/net/http/#Header">Header</a>) Set(key, value <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>)</pre>
				<p>
Set添加键值对到h，如键已存在则会用只有新值一个元素的切片取代旧值切片。
</p>

				
				
				
			
				
				<h3 id="Header.Write">func (Header) <a href="https://golang-china.appspot.com/src/net/http/header.go?s=1433:1473#L46">Write</a></h3>
				<pre>func (h <a href="https://golang-china.appspot.com/pkg/net/http/#Header">Header</a>) Write(w <a href="https://golang-china.appspot.com/pkg/io/">io</a>.<a href="https://golang-china.appspot.com/pkg/io/#Writer">Writer</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a></pre>
				<p>
Write以有线格式将头域写入w。
</p>

				
				
				
			
				
				<h3 id="Header.WriteSubset">func (Header) <a href="https://golang-china.appspot.com/src/net/http/header.go?s=3676:3747#L135">WriteSubset</a></h3>
				<pre>func (h <a href="https://golang-china.appspot.com/pkg/net/http/#Header">Header</a>) WriteSubset(w <a href="https://golang-china.appspot.com/pkg/io/">io</a>.<a href="https://golang-china.appspot.com/pkg/io/#Writer">Writer</a>, exclude map[<a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>]<a href="https://golang-china.appspot.com/pkg/builtin/#bool">bool</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a></pre>
				<p>
WriteSubset以有线格式将头域写入w。当exclude不为nil时，如果h的键值对的键在exclude中存在且其对应值为真，该键值对就不会被写入w。
</p>

				
				
				
			
		
			
			
			<h2 id="Hijacker">type <a href="https://golang-china.appspot.com/src/net/http/server.go?s=3112:3427#L86">Hijacker</a></h2>
			<pre>type Hijacker interface {
        <span class="comment">// Hijack lets the caller take over the connection.</span>
        <span class="comment">// After a call to Hijack(), the HTTP server library</span>
        <span class="comment">// will not do anything else with the connection.</span>
        <span class="comment">// It becomes the caller's responsibility to manage</span>
        <span class="comment">// and close the connection.</span>
        Hijack() (<a href="https://golang-china.appspot.com/pkg/net/">net</a>.<a href="https://golang-china.appspot.com/pkg/net/#Conn">Conn</a>, *<a href="https://golang-china.appspot.com/pkg/bufio/">bufio</a>.<a href="https://golang-china.appspot.com/pkg/bufio/#ReadWriter">ReadWriter</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)
}</pre>
			<p>
HTTP处理器ResponseWriter接口参数的下层如果实现了Hijacker接口，可以让HTTP处理器接管该连接。
</p>


			

			

			<div id="example_Hijacker" class="toggle">
	<div class="collapsed">
<!--
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
-->
		<p class="exampleHeading toggleButton">▹ <span class="text">示例</span></p>
	</div>
	<div class="expanded">
<!--
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
-->
		<p class="exampleHeading toggleButton">▾ <span class="text">示例</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code">package main

import (
	"fmt"
	"log"
	"net/http"
)

func main() {
	http.HandleFunc("/hijack", func(w http.ResponseWriter, r *http.Request) {
		hj, ok := w.(http.Hijacker)
		if !ok {
			http.Error(w, "webserver doesn't support hijacking", http.StatusInternalServerError)
			return
		}
		conn, bufrw, err := hj.Hijack()
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		// Don't forget to close the connection:
		defer conn.Close()
		bufrw.WriteString("Now we're speaking raw TCP. Say hi: ")
		bufrw.Flush()
		s, err := bufrw.ReadString('\n')
		if err != nil {
			log.Printf("error reading string: %v", err)
			return
		}
		fmt.Fprintf(bufrw, "You said: %q\nBye.\n", s)
		bufrw.Flush()
	})
}
</textarea></div>
				<div class="output"><pre></pre></div>
				<div class="buttons">
<!--
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					<a class="share" title="Share this code">Share</a>
-->
					<a class="run" title="运行此代码[Shift+Enter]">运行</a>
					<a class="fmt" title="格式化此代码">格式化</a>
					<a class="share" title="分享此代码">分享</a>
				</div>
			</div>
		
	</div>
</div>

			
			

			

			
		
			
			
			<h2 id="ProtocolError">type <a href="https://golang-china.appspot.com/src/net/http/request.go?s=668:717#L26">ProtocolError</a></h2>
			<pre>type ProtocolError struct {
        ErrorString <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>
}</pre>
			<p>
HTTP请求解析错误。
</p>


			

			

			
			
			

			

			
				
				<h3 id="ProtocolError.Error">func (*ProtocolError) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=719:759#L30">Error</a></h3>
				<pre>func (err *<a href="https://golang-china.appspot.com/pkg/net/http/#ProtocolError">ProtocolError</a>) Error() <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Request">type <a href="https://golang-china.appspot.com/src/net/http/request.go?s=2057:8004#L64">Request</a></h2>
			<pre>type Request struct {
        <span class="comment">// Method specifies the HTTP method (GET, POST, PUT, etc.).</span>
        <span class="comment">// For client requests an empty string means GET.</span>
        Method <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>

        <span class="comment">// URL specifies either the URI being requested (for server</span>
        <span class="comment">// requests) or the URL to access (for client requests).</span>
        <span class="comment">//</span>
        <span class="comment">// For server requests the URL is parsed from the URI</span>
        <span class="comment">// supplied on the Request-Line as stored in RequestURI.  For</span>
        <span class="comment">// most requests, fields other than Path and RawQuery will be</span>
        <span class="comment">// empty. (See RFC 2616, Section 5.1.2)</span>
        <span class="comment">//</span>
        <span class="comment">// For client requests, the URL's Host specifies the server to</span>
        <span class="comment">// connect to, while the Request's Host field optionally</span>
        <span class="comment">// specifies the Host header value to send in the HTTP</span>
        <span class="comment">// request.</span>
        URL *<a href="https://golang-china.appspot.com/pkg/net/url/">url</a>.<a href="https://golang-china.appspot.com/pkg/net/url/#URL">URL</a>

        <span class="comment">// The protocol version for incoming requests.</span>
        <span class="comment">// Client requests always use HTTP/1.1.</span>
        Proto      <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a> <span class="comment">// "HTTP/1.0"</span>
        ProtoMajor <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>    <span class="comment">// 1</span>
        ProtoMinor <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>    <span class="comment">// 0</span>

        <span class="comment">// A header maps request lines to their values.</span>
        <span class="comment">// If the header says</span>
        <span class="comment">//</span>
        <span class="comment">//	accept-encoding: gzip, deflate</span>
        <span class="comment">//	Accept-Language: en-us</span>
        <span class="comment">//	Connection: keep-alive</span>
        <span class="comment">//</span>
        <span class="comment">// then</span>
        <span class="comment">//</span>
        <span class="comment">//	Header = map[string][]string{</span>
        <span class="comment">//		"Accept-Encoding": {"gzip, deflate"},</span>
        <span class="comment">//		"Accept-Language": {"en-us"},</span>
        <span class="comment">//		"Connection": {"keep-alive"},</span>
        <span class="comment">//	}</span>
        <span class="comment">//</span>
        <span class="comment">// HTTP defines that header names are case-insensitive.</span>
        <span class="comment">// The request parser implements this by canonicalizing the</span>
        <span class="comment">// name, making the first character and any characters</span>
        <span class="comment">// following a hyphen uppercase and the rest lowercase.</span>
        <span class="comment">//</span>
        <span class="comment">// For client requests certain headers are automatically</span>
        <span class="comment">// added and may override values in Header.</span>
        <span class="comment">//</span>
        <span class="comment">// See the documentation for the Request.Write method.</span>
        Header <a href="https://golang-china.appspot.com/pkg/net/http/#Header">Header</a>

        <span class="comment">// Body is the request's body.</span>
        <span class="comment">//</span>
        <span class="comment">// For client requests a nil body means the request has no</span>
        <span class="comment">// body, such as a GET request. The HTTP Client's Transport</span>
        <span class="comment">// is responsible for calling the Close method.</span>
        <span class="comment">//</span>
        <span class="comment">// For server requests the Request Body is always non-nil</span>
        <span class="comment">// but will return EOF immediately when no body is present.</span>
        <span class="comment">// The Server will close the request body. The ServeHTTP</span>
        <span class="comment">// Handler does not need to.</span>
        Body <a href="https://golang-china.appspot.com/pkg/io/">io</a>.<a href="https://golang-china.appspot.com/pkg/io/#ReadCloser">ReadCloser</a>

        <span class="comment">// ContentLength records the length of the associated content.</span>
        <span class="comment">// The value -1 indicates that the length is unknown.</span>
        <span class="comment">// Values &gt;= 0 indicate that the given number of bytes may</span>
        <span class="comment">// be read from Body.</span>
        <span class="comment">// For client requests, a value of 0 means unknown if Body is not nil.</span>
        ContentLength <a href="https://golang-china.appspot.com/pkg/builtin/#int64">int64</a>

        <span class="comment">// TransferEncoding lists the transfer encodings from outermost to</span>
        <span class="comment">// innermost. An empty list denotes the "identity" encoding.</span>
        <span class="comment">// TransferEncoding can usually be ignored; chunked encoding is</span>
        <span class="comment">// automatically added and removed as necessary when sending and</span>
        <span class="comment">// receiving requests.</span>
        TransferEncoding []<a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>

        <span class="comment">// Close indicates whether to close the connection after</span>
        <span class="comment">// replying to this request (for servers) or after sending</span>
        <span class="comment">// the request (for clients).</span>
        Close <a href="https://golang-china.appspot.com/pkg/builtin/#bool">bool</a>

        <span class="comment">// For server requests Host specifies the host on which the</span>
        <span class="comment">// URL is sought. Per RFC 2616, this is either the value of</span>
        <span class="comment">// the "Host" header or the host name given in the URL itself.</span>
        <span class="comment">// It may be of the form "host:port".</span>
        <span class="comment">//</span>
        <span class="comment">// For client requests Host optionally overrides the Host</span>
        <span class="comment">// header to send. If empty, the Request.Write method uses</span>
        <span class="comment">// the value of URL.Host.</span>
        Host <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>

        <span class="comment">// Form contains the parsed form data, including both the URL</span>
        <span class="comment">// field's query parameters and the POST or PUT form data.</span>
        <span class="comment">// This field is only available after ParseForm is called.</span>
        <span class="comment">// The HTTP client ignores Form and uses Body instead.</span>
        Form <a href="https://golang-china.appspot.com/pkg/net/url/">url</a>.<a href="https://golang-china.appspot.com/pkg/net/url/#Values">Values</a>

        <span class="comment">// PostForm contains the parsed form data from POST, PATCH,</span>
        <span class="comment">// or PUT body parameters.</span>
        <span class="comment">//</span>
        <span class="comment">// This field is only available after ParseForm is called.</span>
        <span class="comment">// The HTTP client ignores PostForm and uses Body instead.</span>
        PostForm <a href="https://golang-china.appspot.com/pkg/net/url/">url</a>.<a href="https://golang-china.appspot.com/pkg/net/url/#Values">Values</a>

        <span class="comment">// MultipartForm is the parsed multipart form, including file uploads.</span>
        <span class="comment">// This field is only available after ParseMultipartForm is called.</span>
        <span class="comment">// The HTTP client ignores MultipartForm and uses Body instead.</span>
        MultipartForm *<a href="https://golang-china.appspot.com/pkg/mime/multipart/">multipart</a>.<a href="https://golang-china.appspot.com/pkg/mime/multipart/#Form">Form</a>

        <span class="comment">// Trailer specifies additional headers that are sent after the request</span>
        <span class="comment">// body.</span>
        <span class="comment">//</span>
        <span class="comment">// For server requests the Trailer map initially contains only the</span>
        <span class="comment">// trailer keys, with nil values. (The client declares which trailers it</span>
        <span class="comment">// will later send.)  While the handler is reading from Body, it must</span>
        <span class="comment">// not reference Trailer. After reading from Body returns EOF, Trailer</span>
        <span class="comment">// can be read again and will contain non-nil values, if they were sent</span>
        <span class="comment">// by the client.</span>
        <span class="comment">//</span>
        <span class="comment">// For client requests Trailer must be initialized to a map containing</span>
        <span class="comment">// the trailer keys to later send. The values may be nil or their final</span>
        <span class="comment">// values. The ContentLength must be 0 or -1, to send a chunked request.</span>
        <span class="comment">// After the HTTP request is sent the map values can be updated while</span>
        <span class="comment">// the request body is read. Once the body returns EOF, the caller must</span>
        <span class="comment">// not mutate Trailer.</span>
        <span class="comment">//</span>
        <span class="comment">// Few HTTP clients, servers, or proxies support HTTP trailers.</span>
        Trailer <a href="https://golang-china.appspot.com/pkg/net/http/#Header">Header</a>

        <span class="comment">// RemoteAddr allows HTTP servers and other software to record</span>
        <span class="comment">// the network address that sent the request, usually for</span>
        <span class="comment">// logging. This field is not filled in by ReadRequest and</span>
        <span class="comment">// has no defined format. The HTTP server in this package</span>
        <span class="comment">// sets RemoteAddr to an "IP:port" address before invoking a</span>
        <span class="comment">// handler.</span>
        <span class="comment">// This field is ignored by the HTTP client.</span>
        RemoteAddr <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>

        <span class="comment">// RequestURI is the unmodified Request-URI of the</span>
        <span class="comment">// Request-Line (RFC 2616, Section 5.1) as sent by the client</span>
        <span class="comment">// to a server. Usually the URL field should be used instead.</span>
        <span class="comment">// It is an error to set this field in an HTTP client request.</span>
        RequestURI <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>

        <span class="comment">// TLS allows HTTP servers and other software to record</span>
        <span class="comment">// information about the TLS connection on which the request</span>
        <span class="comment">// was received. This field is not filled in by ReadRequest.</span>
        <span class="comment">// The HTTP server in this package sets the field for</span>
        <span class="comment">// TLS-enabled connections before invoking a handler;</span>
        <span class="comment">// otherwise it leaves the field nil.</span>
        <span class="comment">// This field is ignored by the HTTP client.</span>
        TLS *<a href="https://golang-china.appspot.com/pkg/crypto/tls/">tls</a>.<a href="https://golang-china.appspot.com/pkg/crypto/tls/#ConnectionState">ConnectionState</a>
}</pre>
			<p>
Request类型代表一个服务端接受到的或者客户端发送出去的HTTP请求。
</p>
<p>
Request各字段的意义和用途在服务端和客户端是不同的。除了字段本身上方文档，还可参见Request.Write方法和RoundTripper接口的文档。
</p>


			

			

			
			
			

			
				
				<h3 id="NewRequest">func <a href="https://golang-china.appspot.com/src/net/http/request.go?s=16498:16570#L507">NewRequest</a></h3>
				<pre>func NewRequest(method, urlStr <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, body <a href="https://golang-china.appspot.com/pkg/io/">io</a>.<a href="https://golang-china.appspot.com/pkg/io/#Reader">Reader</a>) (*<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
NewRequest使用指定的方法、网址和可选的主题创建并返回一个新的*Request。
</p>
<p>
如果body参数实现了io.Closer接口，Request返回值的Body
字段会被设置为body，并会被Client类型的Do、Post和PostFOrm方法以及Transport.RoundTrip方法关闭。
</p>

				
				
			
				
				<h3 id="ReadRequest">func <a href="https://golang-china.appspot.com/src/net/http/request.go?s=19081:19140#L607">ReadRequest</a></h3>
				<pre>func ReadRequest(b *<a href="https://golang-china.appspot.com/pkg/bufio/">bufio</a>.<a href="https://golang-china.appspot.com/pkg/bufio/#Reader">Reader</a>) (req *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>, err <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadRequest从b读取并解析出一个HTTP请求。（本函数主要用在服务端从下层获取请求）
</p>

				
				
			

			
				
				<h3 id="Request.AddCookie">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=9075:9113#L251">AddCookie</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) AddCookie(c *<a href="https://golang-china.appspot.com/pkg/net/http/#Cookie">Cookie</a>)</pre>
				<p>
AddCookie向请求中添加一个cookie。按照RFC 6265 section
5.4的跪地，AddCookie不会添加超过一个Cookie头字段。这表示所有的cookie都写在同一行，用分号分隔（cookie内部用逗号分隔属性）。
</p>

				
				
				
			
				
				<h3 id="Request.BasicAuth">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=17347:17413#L543">BasicAuth</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) BasicAuth() (username, password <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, ok <a href="https://golang-china.appspot.com/pkg/builtin/#bool">bool</a>)</pre>
				<p>
BasicAuth returns the username and password provided in the request's
Authorization header, if the request uses HTTP Basic Authentication. See RFC
2617, Section 2.
</p>

				
				
				
			
				
				<h3 id="Request.Cookie">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=8693:8747#L240">Cookie</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) Cookie(name <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) (*<a href="https://golang-china.appspot.com/pkg/net/http/#Cookie">Cookie</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
Cookie返回请求中名为name的cookie，如果未找到该cookie会返回nil, ErrNoCookie。
</p>

				
				
				
			
				
				<h3 id="Request.Cookies">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=8461:8498#L232">Cookies</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) Cookies() []*<a href="https://golang-china.appspot.com/pkg/net/http/#Cookie">Cookie</a></pre>
				<p>
Cookies解析并返回该请求的Cookie头设置的cookie。
</p>

				
				
				
			
				
				<h3 id="Request.FormFile">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=26992:27077#L899">FormFile</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) FormFile(key <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) (<a href="https://golang-china.appspot.com/pkg/mime/multipart/">multipart</a>.<a href="https://golang-china.appspot.com/pkg/mime/multipart/#File">File</a>, *<a href="https://golang-china.appspot.com/pkg/mime/multipart/">multipart</a>.<a href="https://golang-china.appspot.com/pkg/mime/multipart/#FileHeader">FileHeader</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
FormFile返回以key为键查询r.MultipartForm字段得到结果中的第一个文件和它的信息。如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。查询失败会返回ErrMissingFile错误。
</p>

				
				
				
			
				
				<h3 id="Request.FormValue">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=26230:26276#L873">FormValue</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) FormValue(key <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a></pre>
				<p>
FormValue返回key为键查询r.Form字段得到结果[]string切片的第一个值。POST和PUT主体中的同名参数优先于URL查询字符串。如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。
</p>

				
				
				
			
				
				<h3 id="Request.MultipartReader">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=10412:10474#L284">MultipartReader</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) MultipartReader() (*<a href="https://golang-china.appspot.com/pkg/mime/multipart/">multipart</a>.<a href="https://golang-china.appspot.com/pkg/mime/multipart/#Reader">Reader</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
如果请求是multipart/form-data
POST请求，MultipartReader返回一个multipart.Reader接口，否则返回nil和一个错误。使用本函数代替ParseMultipartForm，可以将r.Body作为流处理。
</p>

				
				
				
			
				
				<h3 id="Request.ParseForm">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=24256:24291#L795">ParseForm</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) ParseForm() <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a></pre>
				<p>
ParseForm解析URL中的查询字符串，并将解析结果更新到r.Form字段。
</p>
<p>
对于POST或PUT请求，ParseForm还会将body当作表单解析，并将结果既更新到r.PostForm也更新到r.Form。解析结果中，POST或PUT请求主体要优先于URL查询字符串（同名变量，主体的值在查询字符串的值前面）。
</p>
<p>
如果请求的主体的大小没有被MaxBytesReader函数设定限制，其大小默认限制为开头10MB。
</p>
<p>
ParseMultipartForm会自动调用ParseForm。重复调用本方法是无意义的。
</p>

				
				
				
			
				
				<h3 id="Request.ParseMultipartForm">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=25311:25370#L836">ParseMultipartForm</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) ParseMultipartForm(maxMemory <a href="https://golang-china.appspot.com/pkg/builtin/#int64">int64</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a></pre>
				<p>
ParseMultipartForm将请求的主体作为multipart/form-data解析。请求的整个主体都会被解析，得到的文件记录最多maxMemery字节保存在内存，其余部分保存在硬盘的temp文件里。如果必要，ParseMultipartForm会自行调用ParseForm。重复调用本方法是无意义的。
</p>

				
				
				
			
				
				<h3 id="Request.PostFormValue">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=26671:26721#L887">PostFormValue</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) PostFormValue(key <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a></pre>
				<p>
PostFormValue返回key为键查询r.PostForm字段得到结果[]string切片的第一个值。如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。
</p>

				
				
				
			
				
				<h3 id="Request.ProtoAtLeast">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=8104:8157#L221">ProtoAtLeast</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) ProtoAtLeast(major, minor <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#bool">bool</a></pre>
				<p>
ProtoAtLeast报告该请求使用的HTTP协议版本至少是major.minor。
</p>

				
				
				
			
				
				<h3 id="Request.Referer">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=9783:9817#L268">Referer</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) Referer() <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a></pre>
				<p>
Referer返回请求中的访问来路信息。（请求的Referer头）
</p>
<p>
Referer在请求中就是拼错了的，这是HTTP早期就有的错误。该值也可以从用Header["Referer"]获取；
让获取Referer字段变成方法的好处是，编译器可以诊断使用正确单词拼法的req.Referrer()的程序，但却不能诊断使用Header["Referrer"]的程序。
</p>

				
				
				
			
				
				<h3 id="Request.SetBasicAuth">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=18235:18292#L575">SetBasicAuth</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) SetBasicAuth(username, password <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>)</pre>
				<p>
SetBasicAuth使用提供的用户名和密码，采用HTTP基本认证，设置请求的Authorization头。HTTP基本认证会明码传送用户名和密码。
</p>

				
				
				
			
				
				<h3 id="Request.UserAgent">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=8314:8350#L227">UserAgent</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) UserAgent() <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a></pre>
				<p>
UserAgent返回请求中的客户端用户代理信息（请求的User-Agent头）。
</p>

				
				
				
			
				
				<h3 id="Request.Write">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=12110:12152#L339">Write</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) Write(w <a href="https://golang-china.appspot.com/pkg/io/">io</a>.<a href="https://golang-china.appspot.com/pkg/io/#Writer">Writer</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a></pre>
				<p>
Write方法以有线格式将HTTP/1.1请求写入w（用于将请求写入下层TCPConn等）。本方法会考虑请求的如下字段：
</p>
<pre>Host
URL
Method (defaults to "GET")
Header
ContentLength
TransferEncoding
Body
</pre>
<p>
如果存在Body，ContentLength字段&lt;=
0且TransferEncoding字段未显式设置为["identity"]，Write方法会显式添加"Transfer-Encoding:
chunked"到请求的头域。Body字段会在发送完请求后关闭。
</p>

				
				
				
			
				
				<h3 id="Request.WriteProxy">func (*Request) <a href="https://golang-china.appspot.com/src/net/http/request.go?s=12545:12592#L349">WriteProxy</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) WriteProxy(w <a href="https://golang-china.appspot.com/pkg/io/">io</a>.<a href="https://golang-china.appspot.com/pkg/io/#Writer">Writer</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a></pre>
				<p>
WriteProxy类似Write但会将请求以HTTP代理期望的格式发送。
</p>
<p>
尤其是，按照RFC 2616 Section
5.1.2，WriteProxy会使用绝对URI（包括协议和主机名）来初始化请求的第1行（Request-URI行）。无论何种情况，WriteProxy都会使用r.Host或r.URL.Host设置Host头。
</p>

				
				
				
			
		
			
			
			<h2 id="Response">type <a href="https://golang-china.appspot.com/src/net/http/response.go?s=512:2849#L19">Response</a></h2>
			<pre>type Response struct {
        Status     <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a> <span class="comment">// e.g. "200 OK"</span>
        StatusCode <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>    <span class="comment">// e.g. 200</span>
        Proto      <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a> <span class="comment">// e.g. "HTTP/1.0"</span>
        ProtoMajor <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>    <span class="comment">// e.g. 1</span>
        ProtoMinor <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>    <span class="comment">// e.g. 0</span>

        <span class="comment">// Header maps header keys to values.  If the response had multiple</span>
        <span class="comment">// headers with the same key, they may be concatenated, with comma</span>
        <span class="comment">// delimiters.  (Section 4.2 of RFC 2616 requires that multiple headers</span>
        <span class="comment">// be semantically equivalent to a comma-delimited sequence.) Values</span>
        <span class="comment">// duplicated by other fields in this struct (e.g., ContentLength) are</span>
        <span class="comment">// omitted from Header.</span>
        <span class="comment">//</span>
        <span class="comment">// Keys in the map are canonicalized (see CanonicalHeaderKey).</span>
        Header <a href="https://golang-china.appspot.com/pkg/net/http/#Header">Header</a>

        <span class="comment">// Body represents the response body.</span>
        <span class="comment">//</span>
        <span class="comment">// The http Client and Transport guarantee that Body is always</span>
        <span class="comment">// non-nil, even on responses without a body or responses with</span>
        <span class="comment">// a zero-length body. It is the caller's responsibility to</span>
        <span class="comment">// close Body. The default HTTP client's Transport does not</span>
        <span class="comment">// attempt to reuse HTTP/1.0 or HTTP/1.1 TCP connections</span>
        <span class="comment">// ("keep-alive") unless the Body is read to completion and is</span>
        <span class="comment">// closed.</span>
        <span class="comment">//</span>
        <span class="comment">// The Body is automatically dechunked if the server replied</span>
        <span class="comment">// with a "chunked" Transfer-Encoding.</span>
        Body <a href="https://golang-china.appspot.com/pkg/io/">io</a>.<a href="https://golang-china.appspot.com/pkg/io/#ReadCloser">ReadCloser</a>

        <span class="comment">// ContentLength records the length of the associated content.  The</span>
        <span class="comment">// value -1 indicates that the length is unknown.  Unless Request.Method</span>
        <span class="comment">// is "HEAD", values &gt;= 0 indicate that the given number of bytes may</span>
        <span class="comment">// be read from Body.</span>
        ContentLength <a href="https://golang-china.appspot.com/pkg/builtin/#int64">int64</a>

        <span class="comment">// Contains transfer encodings from outer-most to inner-most. Value is</span>
        <span class="comment">// nil, means that "identity" encoding is used.</span>
        TransferEncoding []<a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>

        <span class="comment">// Close records whether the header directed that the connection be</span>
        <span class="comment">// closed after reading Body.  The value is advice for clients: neither</span>
        <span class="comment">// ReadResponse nor Response.Write ever closes a connection.</span>
        Close <a href="https://golang-china.appspot.com/pkg/builtin/#bool">bool</a>

        <span class="comment">// Trailer maps trailer keys to values, in the same</span>
        <span class="comment">// format as the header.</span>
        Trailer <a href="https://golang-china.appspot.com/pkg/net/http/#Header">Header</a>

        <span class="comment">// The Request that was sent to obtain this Response.</span>
        <span class="comment">// Request's Body is nil (having already been consumed).</span>
        <span class="comment">// This is only populated for Client requests.</span>
        Request *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>

        <span class="comment">// TLS contains information about the TLS connection on which the</span>
        <span class="comment">// response was received. It is nil for unencrypted responses.</span>
        <span class="comment">// The pointer is shared between responses and should not be</span>
        <span class="comment">// modified.</span>
        TLS *<a href="https://golang-china.appspot.com/pkg/crypto/tls/">tls</a>.<a href="https://golang-china.appspot.com/pkg/crypto/tls/#ConnectionState">ConnectionState</a>
}</pre>
			<p>
Response代表一个HTTP请求的回复。
</p>


			

			

			
			
			

			
				
				<h3 id="Get">func <a href="https://golang-china.appspot.com/src/net/http/client.go?s=9157:9205#L270">Get</a></h3>
				<pre>func Get(url <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) (resp *<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>, err <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
Get向指定的URL发出一个GET请求，如果回应的状态码如下，Get会在调用c.CheckRedirect后执行重定向：
</p>
<pre>301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
</pre>
<p>
如果c.CheckRedirect执行失败或存在HTTP协议错误时，本方法将返回该错误；如果回应的状态码不是2xx，本方法并不会返回错误。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。
</p>
<p>
Get是对包变量DefaultClient的Get方法的包装。
</p>

				<div id="example_Get" class="toggle">
	<div class="collapsed">
<!--
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
-->
		<p class="exampleHeading toggleButton">▹ <span class="text">示例</span></p>
	</div>
	<div class="expanded">
<!--
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
-->
		<p class="exampleHeading toggleButton">▾ <span class="text">示例</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code">package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
)

func main() {
	res, err := http.Get("http://www.google.com/robots.txt")
	if err != nil {
		log.Fatal(err)
	}
	robots, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("%s", robots)
}
</textarea></div>
				<div class="output"><pre></pre></div>
				<div class="buttons">
<!--
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					<a class="share" title="Share this code">Share</a>
-->
					<a class="run" title="运行此代码[Shift+Enter]">运行</a>
					<a class="fmt" title="格式化此代码">格式化</a>
					<a class="share" title="分享此代码">分享</a>
				</div>
			</div>
		
	</div>
</div>

				
			
				
				<h3 id="Head">func <a href="https://golang-china.appspot.com/src/net/http/client.go?s=15876:15925#L500">Head</a></h3>
				<pre>func Head(url <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) (resp *<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>, err <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
Head向指定的URL发出一个HEAD请求，如果回应的状态码如下，Head会在调用c.CheckRedirect后执行重定向：
</p>
<pre>301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
</pre>
<p>
Head是对包变量DefaultClient的Head方法的包装。
</p>

				
				
			
				
				<h3 id="Post">func <a href="https://golang-china.appspot.com/src/net/http/client.go?s=13774:13856#L443">Post</a></h3>
				<pre>func Post(url <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, bodyType <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, body <a href="https://golang-china.appspot.com/pkg/io/">io</a>.<a href="https://golang-china.appspot.com/pkg/io/#Reader">Reader</a>) (resp *<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>, err <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
Post向指定的URL发出一个POST请求。bodyType为POST数据的类型，
body为POST数据，作为请求的主体。如果参数body实现了io.Closer接口，它会在发送请求后被关闭。调用者有责任在读取完返回值resp的主体后关闭它。
</p>
<p>
Post是对包变量DefaultClient的Post方法的包装。
</p>

				
				
			
				
				<h3 id="PostForm">func <a href="https://golang-china.appspot.com/src/net/http/client.go?s=14867:14937#L474">PostForm</a></h3>
				<pre>func PostForm(url <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, data <a href="https://golang-china.appspot.com/pkg/net/url/">url</a>.<a href="https://golang-china.appspot.com/pkg/net/url/#Values">Values</a>) (resp *<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>, err <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
PostForm向指定的URL发出一个POST请求，url.Values类型的data会被编码为请求的主体。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。
</p>
<p>
PostForm是对包变量DefaultClient的PostForm方法的包装。
</p>

				
				
			
				
				<h3 id="ReadResponse">func <a href="https://golang-china.appspot.com/src/net/http/response.go?s=3894:3961#L109">ReadResponse</a></h3>
				<pre>func ReadResponse(r *<a href="https://golang-china.appspot.com/pkg/bufio/">bufio</a>.<a href="https://golang-china.appspot.com/pkg/bufio/#Reader">Reader</a>, req *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) (*<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadResponse从r读取并返回一个HTTP
回复。req参数是可选的，指定该回复对应的请求（即是对该请求的回复）。如果是nil，将假设请求是GET请求。客户端必须在结束resp.Body的读取后关闭它。读取完毕并关闭后，客户端可以检查resp.Trailer字段获取回复的trailer的键值对。（本函数主要用在客户端从下层获取回复）
</p>

				
				
			

			
				
				<h3 id="Response.Cookies">func (*Response) <a href="https://golang-china.appspot.com/src/net/http/response.go?s=2924:2962#L82">Cookies</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>) Cookies() []*<a href="https://golang-china.appspot.com/pkg/net/http/#Cookie">Cookie</a></pre>
				<p>
Cookies解析并返回该回复中的Set-Cookie头设置的cookie。
</p>

				
				
				
			
				
				<h3 id="Response.Location">func (*Response) <a href="https://golang-china.appspot.com/src/net/http/response.go?s=3289:3336#L92">Location</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>) Location() (*<a href="https://golang-china.appspot.com/pkg/net/url/">url</a>.<a href="https://golang-china.appspot.com/pkg/net/url/#URL">URL</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
Location返回该回复的Location头设置的URL。相对地址的重定向会相对于该回复对应的请求来确定绝对地址。如果回复中没有Location头，会返回nil,
ErrNoLocation。
</p>

				
				
				
			
				
				<h3 id="Response.ProtoAtLeast">func (*Response) <a href="https://golang-china.appspot.com/src/net/http/response.go?s=5472:5526#L177">ProtoAtLeast</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>) ProtoAtLeast(major, minor <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#bool">bool</a></pre>
				<p>
ProtoAtLeast报告该回复使用的HTTP协议版本至少是major.minor。
</p>

				
				
				
			
				
				<h3 id="Response.Write">func (*Response) <a href="https://golang-china.appspot.com/src/net/http/response.go?s=6064:6107#L198">Write</a></h3>
				<pre>func (r *<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>) Write(w <a href="https://golang-china.appspot.com/pkg/io/">io</a>.<a href="https://golang-china.appspot.com/pkg/io/#Writer">Writer</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a></pre>
				<p>
Write以有线格式将回复写入w（用于将回复写入下层TCPConn等）。本方法会考虑如下字段：
</p>
<pre>StatusCode
ProtoMajor
ProtoMinor
Request.Method
TransferEncoding
Trailer
Body
ContentLength
Header（不规范的键名和它对应的值会导致不可预知的行为）
</pre>
<p>
Body字段在发送完回复后会被关闭。
</p>

				
				
				
			
		
			
			
			<h2 id="ResponseWriter">type <a href="https://golang-china.appspot.com/src/net/http/server.go?s=1517:2585#L48">ResponseWriter</a></h2>
			<pre>type ResponseWriter interface {
        <span class="comment">// Header returns the header map that will be sent by</span>
        <span class="comment">// WriteHeader. Changing the header after a call to</span>
        <span class="comment">// WriteHeader (or Write) has no effect unless the modified</span>
        <span class="comment">// headers were declared as trailers by setting the</span>
        <span class="comment">// "Trailer" header before the call to WriteHeader.</span>
        <span class="comment">// To suppress implicit response headers, set their value to nil.</span>
        Header() <a href="https://golang-china.appspot.com/pkg/net/http/#Header">Header</a>

        <span class="comment">// Write writes the data to the connection as part of an HTTP reply.</span>
        <span class="comment">// If WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK)</span>
        <span class="comment">// before writing the data.  If the Header does not contain a</span>
        <span class="comment">// Content-Type line, Write adds a Content-Type set to the result of passing</span>
        <span class="comment">// the initial 512 bytes of written data to DetectContentType.</span>
        Write([]<a href="https://golang-china.appspot.com/pkg/builtin/#byte">byte</a>) (<a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)

        <span class="comment">// WriteHeader sends an HTTP response header with status code.</span>
        <span class="comment">// If WriteHeader is not called explicitly, the first call to Write</span>
        <span class="comment">// will trigger an implicit WriteHeader(http.StatusOK).</span>
        <span class="comment">// Thus explicit calls to WriteHeader are mainly used to</span>
        <span class="comment">// send error codes.</span>
        WriteHeader(<a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>)
}</pre>
			<p>
ResponseWriter接口被HTTP处理器用于构造HTTP回复。
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="RoundTripper">type <a href="https://golang-china.appspot.com/src/net/http/client.go?s=2750:3517#L73">RoundTripper</a></h2>
			<pre>type RoundTripper interface {
        <span class="comment">// RoundTrip executes a single HTTP transaction, returning</span>
        <span class="comment">// the Response for the request req.  RoundTrip should not</span>
        <span class="comment">// attempt to interpret the response.  In particular,</span>
        <span class="comment">// RoundTrip must return err == nil if it obtained a response,</span>
        <span class="comment">// regardless of the response's HTTP status code.  A non-nil</span>
        <span class="comment">// err should be reserved for failure to obtain a response.</span>
        <span class="comment">// Similarly, RoundTrip should not attempt to handle</span>
        <span class="comment">// higher-level protocol details such as redirects,</span>
        <span class="comment">// authentication, or cookies.</span>
        <span class="comment">//</span>
        <span class="comment">// RoundTrip should not modify the request, except for</span>
        <span class="comment">// consuming and closing the Body, including on errors. The</span>
        <span class="comment">// request's URL and Header fields are guaranteed to be</span>
        <span class="comment">// initialized.</span>
        RoundTrip(*<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) (*<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)
}</pre>
			<p>
RoundTripper接口是具有执行单次HTTP事务的能力（接收指定请求的回复）的接口。
</p>
<p>
RoundTripper接口的类型必须可以安全的被多线程同时使用。
</p>


			

			
				<pre>var <span id="DefaultTransport">DefaultTransport</span> <a href="https://golang-china.appspot.com/pkg/net/http/#RoundTripper">RoundTripper</a> = &amp;<a href="https://golang-china.appspot.com/pkg/net/http/#Transport">Transport</a>{
        <a href="https://golang-china.appspot.com/pkg/net/http/#Proxy">Proxy</a>: <a href="https://golang-china.appspot.com/pkg/net/http/#ProxyFromEnvironment">ProxyFromEnvironment</a>,
        <a href="https://golang-china.appspot.com/pkg/net/http/#Dial">Dial</a>: (&amp;<a href="https://golang-china.appspot.com/pkg/net/">net</a>.<a href="https://golang-china.appspot.com/pkg/net/#Dialer">Dialer</a>{
                <a href="https://golang-china.appspot.com/pkg/net/http/#Timeout">Timeout</a>:   30 * <a href="https://golang-china.appspot.com/pkg/time/">time</a>.<a href="https://golang-china.appspot.com/pkg/time/#Second">Second</a>,
                <a href="https://golang-china.appspot.com/pkg/net/http/#KeepAlive">KeepAlive</a>: 30 * <a href="https://golang-china.appspot.com/pkg/time/">time</a>.<a href="https://golang-china.appspot.com/pkg/time/#Second">Second</a>,
        }).<a href="https://golang-china.appspot.com/pkg/net/http/#Dial">Dial</a>,
        <a href="https://golang-china.appspot.com/pkg/net/http/#TLSHandshakeTimeout">TLSHandshakeTimeout</a>: 10 * <a href="https://golang-china.appspot.com/pkg/time/">time</a>.<a href="https://golang-china.appspot.com/pkg/time/#Second">Second</a>,
}</pre>
				<p>
DefaultTransport is the default implementation of Transport and is used by
DefaultClient. It establishes network connections as needed and caches them for
reuse by subsequent calls. It uses HTTP proxies as directed by the $HTTP_PROXY
and $NO_PROXY (or $http_proxy and $no_proxy) environment variables.
</p>

			

			
			
			

			
				
				<h3 id="NewFileTransport">func <a href="https://golang-china.appspot.com/src/net/http/filetransport.go?s=827:876#L20">NewFileTransport</a></h3>
				<pre>func NewFileTransport(fs <a href="https://golang-china.appspot.com/pkg/net/http/#FileSystem">FileSystem</a>) <a href="https://golang-china.appspot.com/pkg/net/http/#RoundTripper">RoundTripper</a></pre>
				<p>
NewFileTransport返回一个RoundTripper接口，使用FileSystem接口fs提供文件访问服务。
返回的RoundTripper接口会忽略接收的请求的URL主机及其他绝大多数属性。
</p>
<p>
NewFileTransport函数的典型使用情况是给Transport类型的值注册"file"协议，如下所示：
</p>
<pre>t := &amp;http.Transport{}
t.RegisterProtocol("file", http.NewFileTransport(http.Dir("/")))
c := &amp;http.Client{Transport: t}
res, err := c.Get("file:///etc/passwd")
...
</pre>

				
				
			

			
		
			
			
			<h2 id="ServeMux">type <a href="https://golang-china.appspot.com/src/net/http/server.go?s=43606:43731#L1466">ServeMux</a></h2>
			<pre>type ServeMux struct {
        <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ServeMux类型是HTTP请求的多路转接器。它会将每一个接收的请求的URL与一个注册模式的列表进行匹配，并调用和URL最匹配的模式的处理器。
</p>
<p>
模式是固定的、由根开始的路径，如"/favicon.ico"，或由根开始的子树，如"/images/"（注意结尾的斜杠）。较长的模式优先于较短的模式，因此如果模式"/images/"和"/images/thumbnails/"都注册了处理器，后一个处理器会用于路径以"/images/thumbnails/"开始的请求，前一个处理器会接收到其余的路径在"/images/"子树下的请求。
</p>
<p>
注意，因为以斜杠结尾的模式代表一个由根开始的子树，模式"/"会匹配所有的未被其他注册的模式匹配的路径，而不仅仅是路径"/"。
</p>
<p>
模式也能（可选地）以主机名开始，表示只匹配该主机上的路径。指定主机的模式优先于一般的模式，因此一个注册了两个模式"/codesearch"和"codesearch.google.com/"的处理器不会接管目标为"<a href="http://www.google.com/">http://www.google.com/</a>"的请求。
</p>
<p>
ServeMux还会注意到请求的URL路径的无害化，将任何路径中包含"."或".."元素的请求重定向到等价的没有这两种元素的URL。（参见path.Clean函数）
</p>


			

			

			
			
			

			
				
				<h3 id="NewServeMux">func <a href="https://golang-china.appspot.com/src/net/http/server.go?s=43862:43890#L1479">NewServeMux</a></h3>
				<pre>func NewServeMux() *<a href="https://golang-china.appspot.com/pkg/net/http/#ServeMux">ServeMux</a></pre>
				<p>
NewServeMux创建并返回一个新的*ServeMux
</p>

				
				
			

			
				
				<h3 id="ServeMux.Handle">func (*ServeMux) <a href="https://golang-china.appspot.com/src/net/http/server.go?s=46907:46967#L1591">Handle</a></h3>
				<pre>func (mux *<a href="https://golang-china.appspot.com/pkg/net/http/#ServeMux">ServeMux</a>) Handle(pattern <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, handler <a href="https://golang-china.appspot.com/pkg/net/http/#Handler">Handler</a>)</pre>
				<p>
Handle注册HTTP处理器handler和对应的模式pattern。如果该模式已经注册有一个处理器，Handle会panic。
</p>

				
				<div id="example_ServeMux_Handle" class="toggle">
	<div class="collapsed">
<!--
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
-->
		<p class="exampleHeading toggleButton">▹ <span class="text">示例</span></p>
	</div>
	<div class="expanded">
<!--
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
-->
		<p class="exampleHeading toggleButton">▾ <span class="text">示例</span></p>
		
		
		
<!--
			<p>Code:</p>
-->
			<p>代码：</p>
			<pre class="code">    mux := http.NewServeMux()
    mux.Handle("/api/", apiHandler{})
    mux.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) {
            <span class="comment">// The "/" pattern matches everything, so we need to check</span>
            <span class="comment">// that we're at the root here.</span>
            if req.URL.Path != "/" {
                    http.NotFound(w, req)
                    return
            }
            fmt.Fprintf(w, "Welcome to the home page!")
    })
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="ServeMux.HandleFunc">func (*ServeMux) <a href="https://golang-china.appspot.com/src/net/http/server.go?s=48032:48119#L1629">HandleFunc</a></h3>
				<pre>func (mux *<a href="https://golang-china.appspot.com/pkg/net/http/#ServeMux">ServeMux</a>) HandleFunc(pattern <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, handler func(<a href="https://golang-china.appspot.com/pkg/net/http/#ResponseWriter">ResponseWriter</a>, *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>))</pre>
				<p>
HandleFunc registers the handler function for the given pattern.
</p>

				
				
				
			
				
				<h3 id="ServeMux.Handler">func (*ServeMux) <a href="https://golang-china.appspot.com/src/net/http/server.go?s=45611:45679#L1543">Handler</a></h3>
				<pre>func (mux *<a href="https://golang-china.appspot.com/pkg/net/http/#ServeMux">ServeMux</a>) Handler(r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) (h <a href="https://golang-china.appspot.com/pkg/net/http/#Handler">Handler</a>, pattern <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>)</pre>
				<p>
Handler returns the handler to use for the given request, consulting r.Method,
r.Host, and r.URL.Path. It always returns a non-nil handler. If the path is not
in its canonical form, the handler will be an internally-generated handler that
redirects to the canonical path.
</p>
<p>
Handler also returns the registered pattern that matches the request or, in the
case of internally-generated redirects, the pattern that will match after
following the redirect.
</p>
<p>
If there is no registered handler that applies to the request, Handler returns a
“page not found” handler and an empty pattern.
</p>

				
				
				
			
				
				<h3 id="ServeMux.ServeHTTP">func (*ServeMux) <a href="https://golang-china.appspot.com/src/net/http/server.go?s=46539:46599#L1577">ServeHTTP</a></h3>
				<pre>func (mux *<a href="https://golang-china.appspot.com/pkg/net/http/#ServeMux">ServeMux</a>) ServeHTTP(w <a href="https://golang-china.appspot.com/pkg/net/http/#ResponseWriter">ResponseWriter</a>, r *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>)</pre>
				<p>
ServeHTTP dispatches the request to the handler whose pattern most closely
matches the request URL.
</p>

				
				
				
			
		
			
			
			<h2 id="Server">type <a href="https://golang-china.appspot.com/src/net/http/server.go?s=49180:50673#L1656">Server</a></h2>
			<pre>type Server struct {
        Addr           <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>        <span class="comment">// TCP address to listen on, ":http" if empty</span>
        Handler        <a href="https://golang-china.appspot.com/pkg/net/http/#Handler">Handler</a>       <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span>
        ReadTimeout    <a href="https://golang-china.appspot.com/pkg/time/">time</a>.<a href="https://golang-china.appspot.com/pkg/time/#Duration">Duration</a> <span class="comment">// maximum duration before timing out read of the request</span>
        WriteTimeout   <a href="https://golang-china.appspot.com/pkg/time/">time</a>.<a href="https://golang-china.appspot.com/pkg/time/#Duration">Duration</a> <span class="comment">// maximum duration before timing out write of the response</span>
        MaxHeaderBytes <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>           <span class="comment">// maximum size of request headers, DefaultMaxHeaderBytes if 0</span>
        TLSConfig      *<a href="https://golang-china.appspot.com/pkg/crypto/tls/">tls</a>.<a href="https://golang-china.appspot.com/pkg/crypto/tls/#Config">Config</a>   <span class="comment">// optional TLS config, used by ListenAndServeTLS</span>

        <span class="comment">// TLSNextProto optionally specifies a function to take over</span>
        <span class="comment">// ownership of the provided TLS connection when an NPN</span>
        <span class="comment">// protocol upgrade has occurred.  The map key is the protocol</span>
        <span class="comment">// name negotiated. The Handler argument should be used to</span>
        <span class="comment">// handle HTTP requests and will initialize the Request's TLS</span>
        <span class="comment">// and RemoteAddr if not already set.  The connection is</span>
        <span class="comment">// automatically closed when the function returns.</span>
        TLSNextProto map[<a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>]func(*<a href="https://golang-china.appspot.com/pkg/net/http/#Server">Server</a>, *<a href="https://golang-china.appspot.com/pkg/crypto/tls/">tls</a>.<a href="https://golang-china.appspot.com/pkg/crypto/tls/#Conn">Conn</a>, <a href="https://golang-china.appspot.com/pkg/net/http/#Handler">Handler</a>)

        <span class="comment">// ConnState specifies an optional callback function that is</span>
        <span class="comment">// called when a client connection changes state. See the</span>
        <span class="comment">// ConnState type and associated constants for details.</span>
        ConnState func(<a href="https://golang-china.appspot.com/pkg/net/">net</a>.<a href="https://golang-china.appspot.com/pkg/net/#Conn">Conn</a>, <a href="https://golang-china.appspot.com/pkg/net/http/#ConnState">ConnState</a>)

        <span class="comment">// ErrorLog specifies an optional logger for errors accepting</span>
        <span class="comment">// connections and unexpected behavior from handlers.</span>
        <span class="comment">// If nil, logging goes to os.Stderr via the log package's</span>
        <span class="comment">// standard logger.</span>
        ErrorLog *<a href="https://golang-china.appspot.com/pkg/log/">log</a>.<a href="https://golang-china.appspot.com/pkg/log/#Logger">Logger</a>
        <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Server类型定义了运行HTTP服务端的参数。Server的零值是合法的配置。
</p>


			

			

			
			
			

			

			
				
				<h3 id="Server.ListenAndServe">func (*Server) <a href="https://golang-china.appspot.com/src/net/http/server.go?s=52770:52811#L1754">ListenAndServe</a></h3>
				<pre>func (srv *<a href="https://golang-china.appspot.com/pkg/net/http/#Server">Server</a>) ListenAndServe() <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a></pre>
				<p>
ListenAndServe监听srv.Addr指定的TCP地址，并且会调用Serve方法接收到的连接。如果srv.Addr为空字符串，会使用":http"。
</p>

				
				
				
			
				
				<h3 id="Server.ListenAndServeTLS">func (*Server) <a href="https://golang-china.appspot.com/src/net/http/server.go?s=56941:57009#L1898">ListenAndServeTLS</a></h3>
				<pre>func (srv *<a href="https://golang-china.appspot.com/pkg/net/http/#Server">Server</a>) ListenAndServeTLS(certFile, keyFile <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a></pre>
				<p>
ListenAndServeTLS监听srv.Addr确定的TCP地址，并且会调用Serve方法处理接收到的连接。必须提供证书文件和对应的私钥文件。如果证书是由权威机构签发的，certFile参数必须是顺序串联的服务端证书和CA证书。如果srv.Addr为空字符串，会使用":https"。
</p>

				
				
				
			
				
				<h3 id="Server.Serve">func (*Server) <a href="https://golang-china.appspot.com/src/net/http/server.go?s=53192:53238#L1769">Serve</a></h3>
				<pre>func (srv *<a href="https://golang-china.appspot.com/pkg/net/http/#Server">Server</a>) Serve(l <a href="https://golang-china.appspot.com/pkg/net/">net</a>.<a href="https://golang-china.appspot.com/pkg/net/#Listener">Listener</a>) <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a></pre>
				<p>
Serve会接手监听器l收到的每一个连接，并为每一个连接创建一个新的服务go程。该go程会读取请求，然后调用srv.Handler回复请求。
</p>

				
				
				
			
				
				<h3 id="Server.SetKeepAlivesEnabled">func (*Server) <a href="https://golang-china.appspot.com/src/net/http/server.go?s=54213:54258#L1808">SetKeepAlivesEnabled</a></h3>
				<pre>func (s *<a href="https://golang-china.appspot.com/pkg/net/http/#Server">Server</a>) SetKeepAlivesEnabled(v <a href="https://golang-china.appspot.com/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetKeepAlivesEnabled控制是否允许HTTP闲置连接重用（keep-alive）功能。默认该功能总是被启用的。只有资源非常紧张的环境或者服务端在关闭进程中时，才应该关闭该功能。
</p>

				
				
				
			
		
			
			
			<h2 id="Transport">type <a href="https://golang-china.appspot.com/src/net/http/transport.go?s=1324:4038#L39">Transport</a></h2>
			<pre>type Transport struct {

        <span class="comment">// Proxy specifies a function to return a proxy for a given</span>
        <span class="comment">// Request. If the function returns a non-nil error, the</span>
        <span class="comment">// request is aborted with the provided error.</span>
        <span class="comment">// If Proxy is nil or returns a nil *URL, no proxy is used.</span>
        Proxy func(*<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) (*<a href="https://golang-china.appspot.com/pkg/net/url/">url</a>.<a href="https://golang-china.appspot.com/pkg/net/url/#URL">URL</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)

        <span class="comment">// Dial specifies the dial function for creating unencrypted</span>
        <span class="comment">// TCP connections.</span>
        <span class="comment">// If Dial is nil, net.Dial is used.</span>
        Dial func(network, addr <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) (<a href="https://golang-china.appspot.com/pkg/net/">net</a>.<a href="https://golang-china.appspot.com/pkg/net/#Conn">Conn</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)

        <span class="comment">// DialTLS specifies an optional dial function for creating</span>
        <span class="comment">// TLS connections for non-proxied HTTPS requests.</span>
        <span class="comment">//</span>
        <span class="comment">// If DialTLS is nil, Dial and TLSClientConfig are used.</span>
        <span class="comment">//</span>
        <span class="comment">// If DialTLS is set, the Dial hook is not used for HTTPS</span>
        <span class="comment">// requests and the TLSClientConfig and TLSHandshakeTimeout</span>
        <span class="comment">// are ignored. The returned net.Conn is assumed to already be</span>
        <span class="comment">// past the TLS handshake.</span>
        DialTLS func(network, addr <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>) (<a href="https://golang-china.appspot.com/pkg/net/">net</a>.<a href="https://golang-china.appspot.com/pkg/net/#Conn">Conn</a>, <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)

        <span class="comment">// TLSClientConfig specifies the TLS configuration to use with</span>
        <span class="comment">// tls.Client. If nil, the default configuration is used.</span>
        TLSClientConfig *<a href="https://golang-china.appspot.com/pkg/crypto/tls/">tls</a>.<a href="https://golang-china.appspot.com/pkg/crypto/tls/#Config">Config</a>

        <span class="comment">// TLSHandshakeTimeout specifies the maximum amount of time waiting to</span>
        <span class="comment">// wait for a TLS handshake. Zero means no timeout.</span>
        TLSHandshakeTimeout <a href="https://golang-china.appspot.com/pkg/time/">time</a>.<a href="https://golang-china.appspot.com/pkg/time/#Duration">Duration</a>

        <span class="comment">// DisableKeepAlives, if true, prevents re-use of TCP connections</span>
        <span class="comment">// between different HTTP requests.</span>
        DisableKeepAlives <a href="https://golang-china.appspot.com/pkg/builtin/#bool">bool</a>

        <span class="comment">// DisableCompression, if true, prevents the Transport from</span>
        <span class="comment">// requesting compression with an "Accept-Encoding: gzip"</span>
        <span class="comment">// request header when the Request contains no existing</span>
        <span class="comment">// Accept-Encoding value. If the Transport requests gzip on</span>
        <span class="comment">// its own and gets a gzipped response, it's transparently</span>
        <span class="comment">// decoded in the Response.Body. However, if the user</span>
        <span class="comment">// explicitly requested gzip it is not automatically</span>
        <span class="comment">// uncompressed.</span>
        DisableCompression <a href="https://golang-china.appspot.com/pkg/builtin/#bool">bool</a>

        <span class="comment">// MaxIdleConnsPerHost, if non-zero, controls the maximum idle</span>
        <span class="comment">// (keep-alive) to keep per-host.  If zero,</span>
        <span class="comment">// DefaultMaxIdleConnsPerHost is used.</span>
        MaxIdleConnsPerHost <a href="https://golang-china.appspot.com/pkg/builtin/#int">int</a>

        <span class="comment">// ResponseHeaderTimeout, if non-zero, specifies the amount of</span>
        <span class="comment">// time to wait for a server's response headers after fully</span>
        <span class="comment">// writing the request (including its body, if any). This</span>
        <span class="comment">// time does not include the time to read the response body.</span>
        ResponseHeaderTimeout <a href="https://golang-china.appspot.com/pkg/time/">time</a>.<a href="https://golang-china.appspot.com/pkg/time/#Duration">Duration</a>
        <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Transport类型实现了RoundTripper接口，支持http、https和http/https代理。Transport类型可以缓存连接以在未来重用。
</p>
<pre>var DefaultTransport RoundTripper = &amp;Transport{
    Proxy: ProxyFromEnvironment,
    Dial: (&amp;net.Dialer{
        Timeout:   30 * time.Second,
        KeepAlive: 30 * time.Second,
    }).Dial,
    TLSHandshakeTimeout: 10 * time.Second,
}
</pre>
<p>
DefaultTransport是被包变量DefaultClient使用的默认RoundTripper接口。它会根据需要创建网络连接，并缓存以便在之后的请求中重用这些连接。它使用环境变量$HTTP_PROXY和$NO_PROXY（或$http_proxy和$no_proxy）指定的HTTP代理。
</p>


			

			

			
			
			

			

			
				
				<h3 id="Transport.CancelRequest">func (*Transport) <a href="https://golang-china.appspot.com/src/net/http/transport.go?s=8815:8862#L269">CancelRequest</a></h3>
				<pre>func (t *<a href="https://golang-china.appspot.com/pkg/net/http/#Transport">Transport</a>) CancelRequest(req *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>)</pre>
				<p>
CancelRequest通过关闭请求所在的连接取消一个执行中的请求。
</p>

				
				
				
			
				
				<h3 id="Transport.CloseIdleConnections">func (*Transport) <a href="https://golang-china.appspot.com/src/net/http/transport.go?s=8498:8540#L253">CloseIdleConnections</a></h3>
				<pre>func (t *<a href="https://golang-china.appspot.com/pkg/net/http/#Transport">Transport</a>) CloseIdleConnections()</pre>
				<p>
CloseIdleConnections关闭所有之前的请求建立但目前处于闲置状态的连接。本方法不会中断正在使用的连接。
</p>

				
				
				
			
				
				<h3 id="Transport.RegisterProtocol">func (*Transport) <a href="https://golang-china.appspot.com/src/net/http/transport.go?s=7866:7934#L234">RegisterProtocol</a></h3>
				<pre>func (t *<a href="https://golang-china.appspot.com/pkg/net/http/#Transport">Transport</a>) RegisterProtocol(scheme <a href="https://golang-china.appspot.com/pkg/builtin/#string">string</a>, rt <a href="https://golang-china.appspot.com/pkg/net/http/#RoundTripper">RoundTripper</a>)</pre>
				<p>
RegisterProtocol注册一个新的名为scheme的协议。t会将使用scheme协议的请求转交给rt。rt有责任模拟HTTP请求的语义。
</p>
<p>
RegisterProtocol可以被其他包用于提供"ftp"或"file"等协议的实现。
</p>

				
				
				
			
				
				<h3 id="Transport.RoundTrip">func (*Transport) <a href="https://golang-china.appspot.com/src/net/http/transport.go?s=6344:6415#L181">RoundTrip</a></h3>
				<pre>func (t *<a href="https://golang-china.appspot.com/pkg/net/http/#Transport">Transport</a>) RoundTrip(req *<a href="https://golang-china.appspot.com/pkg/net/http/#Request">Request</a>) (resp *<a href="https://golang-china.appspot.com/pkg/net/http/#Response">Response</a>, err <a href="https://golang-china.appspot.com/pkg/builtin/#error">error</a>)</pre>
				<p>
RoundTrip方法实现了RoundTripper接口。
</p>
<p>
高层次的HTTP客户端支持（如管理cookie和重定向）请参见Get、Post等函数和Client类型。
</p>

				
				
				
			
		
	

	





	
	
<!--
		<h2 id="pkg-subdirectories">Subdirectories</h2>
-->
	
		<h2 id="pkg-subdirectories">子目录</h2>
	
	<table class="dir">
	<tbody><tr>
<!--
	<th>Name</th>
-->
	<th>名称</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
<!--
	<th style="text-align: left; width: auto">Synopsis</th>
-->
	<th style="text-align: left; width: auto">摘要</th>
	</tr>
	
		<tr>
		<td><a href="https://golang-china.appspot.com/pkg/net/">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="https://golang-china.appspot.com/pkg/net/http/cgi/">cgi</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">cgi 包实现了RFC3875协议描述的CGI（公共网关接口）.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="https://golang-china.appspot.com/pkg/net/http/cookiejar/">cookiejar</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">cookiejar包实现了保管在内存中的符合RFC 6265标准的http.CookieJar接口。</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="https://golang-china.appspot.com/pkg/net/http/fcgi/">fcgi</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">fcgi 包实现了FastCGI协议.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="https://golang-china.appspot.com/pkg/net/http/httptest/">httptest</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">httptest 包提供HTTP测试的单元工具.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="https://golang-china.appspot.com/pkg/net/http/httputil/">httputil</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="https://golang-china.appspot.com/pkg/net/http/pprof/">pprof</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">pprof 包通过提供HTTP服务返回runtime的统计数据，这个数据是以pprof可视化工具规定的返回格式返回的.</td>
			</tr>
		
	
	</tbody></table>

	



<!--
<div id="footer">
Build version go1.4.2 (appengine-1.9.21).<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> |
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>
-->
<div id="footer">
构建版本 go1.4.2 (appengine-1.9.21).<br>
除<a href="https://developers.google.com/site-policies#restrictions">特别注明</a>外，
本页内容均采用知识共享-署名（CC-BY）3.0协议授权，代码采用<a href="https://golang-china.appspot.com/LICENSE">BSD协议</a>授权。<br>
<a href="https://golang-china.appspot.com/doc/tos.html">服务条款</a> |
<a href="http://www.google.com/intl/en/policies/privacy/">隐私政策</a>
</div>

</div><!-- .container -->
</div><!-- #page -->

<!-- TODO(adonovan): load these from <head> using "defer" attribute? -->
<script type="text/javascript" src="./http - Go 编程语言_files/jquery.js"></script>
<script type="text/javascript" src="./http - Go 编程语言_files/jquery.treeview.js"></script>
<script type="text/javascript" src="./http - Go 编程语言_files/jquery.treeview.edit.js"></script>


<script type="text/javascript" src="./http - Go 编程语言_files/playground.js"></script>

<script type="text/javascript" src="./http - Go 编程语言_files/godocs.js"></script>



</body></html>